
/**
 * Copyright (c) 2015-2016 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENCE file at the root of the project for the full licence.
 *
 * This parser borrows quite liberally from the awesome ES5Parser built by
 * Jonathan Brachth√§user (http://b-studios.de). But, don't worry this implements
 * a C grammar and not a JavaScript grammar as ES5!
 */


// Dependencies
var _       = require('../nodes.js');


ometa CParser  {

    // Helper Rules
    //
    isKeyword :x    = ?this.spec.isKeyword(x),
    nameFirst       = letter | '_',
    nameRest        = nameFirst | digit,
    linebreak       = '\n',
    floatSuff       = ('f' | 'F' | 'l' | 'L'),
    intSuff         = ('u' | 'U' | 'l' | 'L'),


    // Comments
    //
    comment         = ``//'' (~linebreak char)* &linebreak,
                    | fromTo('/*', '*/'),

    space           = ^space | comment | linebreak,

    // Identifiers and Names
    //
    iName           = <nameFirst nameRest*>,
    id              = iName:name ~isKeyword(name)                   -> _.Id(name),
    keyword         = iName:kwd isKeyword(kwd)                      -> _.Keyword(kwd),

    // Numeric Literals
    //
    hexDigit        = digit | range('a', 'f') | range('A', 'F'),
    hex             = <``0x''|``0X'' hexDigit+>:d intSuff?:s        -> _.Number(parseInt(d)).kind('hex', s),

    decimalInt      = '0' | (~'0' digit) digit*,
    expPart         = ('e' | 'E') ('+' | '-')? digit+,

    octal           = <'0' digit+>:d intSuff?:s                     -> _.Number(parseInt(d,8)).kind('oct', s),

    decimal         = <'-'? decimalInt ('.' digit+)? expPart?>:f floatSuff?:s       -> _.Number(f).kind('float', s)
                    | <'-'? ('.' digit+) expPart?>:f                                -> _.Number(f).kind('float', s),

    integer         = <'-'? decimalInt>:d intSuff?:s                -> _.Number(parseInt(d)).kind('int', s),

    number          = hex | octal | decimal | integer,

    // String Literals
    //
    escapeChar      = <'\\' char>:c                                 -> unescape(c),

    string          = '"' (escapeChar | ~'"' char)*:cs '"'          -> _.String(cs.join(''))
                    | ('#' | '`') iName:n                           -> _.String(cs.join('')),

    // Special symbols
    //
    special         = ( ``...'' | ``>>='' | ``<<='' | ``+='' | ``-=''
                  | ``*='' | ``/='' | ``%='' | ``&='' | ``^=''
                  | ``|='' | ``>>'' | ``<<'' | ``++'' | ``--''
                  | ``->'' | ``&&'' | ``||'' | ``<='' | ``>=''
                  | ``=='' | ``!='' | ';' | '{' | '}' | ','
                  | ':' | '=' | '(' | ')' | '[' | ']' | '.'
                  | '&' | '!' | '~' | '-' | '+' | '*' | '/'
                  | '%' | '<' | '>' | '^' | '|' | '?' ):s           -> _.Special(s),


    token: tt       = spaces ( (special | keyword):t ?(t.value) == tt)              -> t
                    | (id | number | string):t ?(t[0] == tt)                        -> t
                    ),


    // Expressions
    //
    // TODO: arg_expr_list .. is it just an alias to expression?
    // FIXME: There could be a difference due to semantics..

    expression      = listOf(#assign_expr, ','):le                  -> _.(le.length > 1? _.SequenceExpr(le) : le[0]),

    assign_expr     = unary_expr:lhs assign_op:op assign_expr:rhs   -> _.AssignExpr(lhs, rhs).operator(op.value())
                    | cond_expr,

    cond_expr       = lor_expr:e "?" expression:t ":" cond_expr:f   -> _.CondExpr(e, t, f)
                    | lor_expr:e                                    -> e,

    // Binary operations
    //
    lor_expr        = lor_expr:x "||" lar_expr:y                    -> _.BinaryExpr(x, y).operator("||")
                    | lar_expr,
    lar_expr        = lar_expr:x "&&" ior_expr:y                    -> _.BinaryExpr(x, y).operator("||")
                    | ior_expr,
    ior_expr        = ior_expr:x "|" xor_expr:y                     -> _.BinaryExpr(x, y).operator("|")
                    | xor_expr,
    xor_expr        = xor_expr:x "^" and_expr:y                     -> _.BinaryExpr(x, y).operator("^")
                    | and_expr,
    and_expr        = and_expr:x "&" eq_expr:x                      -> _.BinaryExpr(x, y).operator("&")
                    | eq_expr,
    eq_expr         = eq_expr:x ( "==" | "!=" ):op rel_expr:y       -> _.BinaryExpr(x, y).operator(op.value())
                    | rel_expr,
    rel_expr        = rel_expr:x ( "<=" | "<"
                                    | ">=" | ">"):op shift_expr:y   -> _.BinaryExpr(x, y).operator(op.value())
                    | shift_expr,
    shift_expr      = shift_expr:x ( "<<" | ">>" ):op add_expr:y    -> _.BinaryExpr(x, y).operator(op.value())
                    | add_expr,
    add_expr        = add_expr:x ( "+" | "-" ) mult_expr:y          -> _.BinaryExpr(x, y).operator(op.value())
                    | mult_expr,
    mult_expr       = mult_expr:x ( "*" | "/" | "%" ) prefix_expr:y -> _.BinaryExpr(x, y).operator(op.value())
                    | prefix_expr

    assign_op       = "=" | "*=" | "/=" | ">>=" | "<<=" | "+=" | "-="
                    | "%=" | "&=" | "|=" | "^=",

    // Unary operators
    //

    // TODO: Add the following rule: prefix_expr = "(" type_name ")" prefix_expr
    //
    prefix_expr     = ( "++" | "--" ):op spacesNoNl unary_expr:e    -> _.UpdateExpr(e).operator(op.value())
                    | unary_expr,

    // TODO: Insert .. "sizeof" "(" type_name ")" in as an option after the first one
    //
    unary_expr      = ( "&" | "*" | "+" | "-"
                            | "~" | "!" ):op prefix_expr:e          -> _.UnaryExpr(e).operator(op.value())
                    | "sizeof" unary_expr:e
                    | postfix_expr,

    postfix_expr    = left_expr:e spacesNoNl ( "++" | "--" ):op     -> _.UpdateExpr(e).operator(op.value()).prefix(false)

    left_expr       = access_expr:p call_expr(p)
                    | access_expr:p member_expr(p)
                    | primary_expr,

    call_expr :p    = "(" listOf(#assign_expr, ','):as ")"          -> _.CallExpr(p, as),

    member_expr :p  = ( "[" expression:e "]"                        -> _.MemberExpr(p, e)
                        |   "." "id":i                              -> _.MemberExpr(p).name(i.value())
                        |   "->" "id":i                             -> _.PointerExpr(p).name(i.value())
                      ),

    primary_expr    = "id"
                    | "const"
                    | "string"
                    | "(" expression:e ")"                          -> _.GroupExpr(e),

    const_expr      = cond_expr,


    // Declaration statements
    // Statements that do "type" specification
    //

    declaration     = decl_specs init_decl* ";",

  decl_specs      = store_cl_spec decl_specs*
                  | type_spec decl_specs*
                  | type_qualifier decl_specs*,

  init_decl       = declarator "=" initializer
                  | declarator,

  store_cl_spec   = "typedef"
                  | "extern"
                  | "static"
                  | "auto"
                  | "register",

  type_spec       = "void"
                  | "char"
                  | "short"
                  | "int"
                  | "long"
                  | "float"
                  | "double"
                  | "signed"
                  | "unsigned"
                  | struct_uni_spec
                  | enum_spec
                  | "type_name",

  struct_uni_spec = struct_o_uni "id" "{" struct_decl_lst "}"
                  | struct_o_uni "{" struct_decl_lst "}"
                  | struct_o_uni "id",

  struct_o_uni    = "struct"
                  | "union",

  struct_decl_lst = struct_decl+,

  struc_decl      = spec_qual_list struct_decl_lst ";",

  spec_qual_list  = type_spec spec_qual_list
                  | type_spec
                  | type_qualifier spec_qual_list
                  | type_qualifier,

  struc_declr_lst = listOf('struct_declr', ","),

  struct_declr    = declarator ":" const_expr
                  | ":" const_expr
                  | declarator,

  enum_spec       = "enum" "id" "{" enumratr_lst "}"
                  | "enum" "{" enumratr_lst "}"
                  | "enum" "id",

  enumratr_lst    = listOf('enumerator', ","),

  enumerator      = "id" "=" const_expr
                  | "id",


  type_qualifier  = "const"
                  | "volatile",

  declarator      = pointer dir_declarator
                  | dir_declarator,

  dir_declarator  = dir_declarator "[" const_expr "]"
                  | dir_declarator "[" "]"
                  | dir_declarator "(" param_type_lst ")"
                  | dir_declarator "(" ident_lst ")"
                  | dir_declarator "(" ")"
                  | "(" declarator ")"
                  | "id",


  pointer         = "*" type_qual_list pointer
                  | "*" type_qual_list
                  | "*" pointer
                  | "*",

  type_qual_list  = type_qualifier+,

  param_type_lst  = param_list "," "..."
                  | param_list,

  param_list      = param_list "," param_decl
                  | param_decl,

  param_decl      = decl_specs declarator
                  | decl_specs abstract_decl
                  | decl_specs,

  ident_list      = ident_list "," "id"
                  | "id",

  type_name       = spec_qual_lst abstract_decl
                  | spec_qual_lst,

  abstract_decl   = pointer dir_abs_declr
                  | dir_abs_declr
                  | pointer,

  dir_abs_declr   = "(" abstract_decl ")"
                  | "[" const_expr "]"
                  | "[" "]"
                  | dir_abs_declr "[" const_expr "]"
                  | dir_abs_declr "[" "]"
                  | "(" param_type_lst ")"
                  | "(" ")"
                  | dir_abs_declr "(" param_type_lst ")"
                  | dir_abs_declr "(" ")",

  initializer     = "{" listOf('initializer_lst', ",") "}"
                  | assign_expr,

  initializer_lst = listOf('initializer', ","),



    // C Statements
    //

  statement       = labeled_stmt            -> console.log("Labeled stmt")
                  | compound_stmt           -> console.log("Compound stmt")
                  | expression_stmt         -> console.log("Expression stmt")
                  | selection_stmt          -> console.log("Selection stmt")
                  | iteration_stmt          -> console.log("Iteration stmt")
                  | jump_stmt               -> console.log("Jump stmt"),

  labeled_stmt    = "id" ":" statement
                  | "case" const_expression ":" statement
                  | "default" ":" statement,

  compound_stmt   = "{" declaration_lst statement_lst "}"
                  | "{" statement_lst "}"
                  | "{" declaration_lst "}"
                  | "{" "}",


  declaration_lst = declaration_lst declaration
                  | declaration,

  statement_lst   = statement+,

  expression_stmt = expression* ";",

  selection_stmt  = "if" "(" expression ")" statement "else" statement
                  | "if" "(" expression ")" statement
                  | "switch" "(" expression ")" statement,


  iteration_stmt  = "while" "(" expression ")" statement                    -> console.log("While! ")
                  | "do" statement "while" "(" expression ")" ";"
                  | "for" "(" expression_stmt expression_stmt ")" statement
                  | "for" "(" expression_stmt expression_stmt expression ")" statement,

  jump_stmt       = "goto" "id" ";"
                  | "continue" ";"
                  | "break" ";"
                  | "return" ";"
                  | "return" expression ";",


  translation_u   = external_decl+,

  external_decl   = function_def            -> console.log("Function def")
                  | declaration,


  function_def    = decl_specs declarator declaration_lst compound_stmt
                  | decl_specs declarator compound_stmt
                  | declarator declaration_lst compound_stmt
                  | declarator compound_stmt,

  topLevel             = translation_u spaces end
}


// Configure position information callback
CParser.position_info = function(input, from to) {

    function position(pos) {
        var line  = 1,
        column = undefined;

        // scroll backwards to next linebreak
        for(var i=pos; i>=0; i--) {

            if(input[i] === "\n") {
                // only for the first time search column
                if(typeof column == 'undefined')
                    column = pos - i;

                line++
            }
        }

        if(line === 1)
            column = pos;

        return {
            line: line,
            column: column
        }
    }

    return {
        source: input.slice(from, to),
        start: position(from),
        end: position(to)
    }
};


CParser.spec = {

    // for C95.. we might have to add more keywords for C99
    keywords:   ["auto", "break", "case", "char", "const", "continue", "default",
                 "do", "double", "else", "enum", "extern", "float", "for", "goto",
                 "if", "int", "long", "register", "return", "short", "signed",
                 "sizeof", "static", "struct", "switch", "typedef", "union",
                 "unsigned", "void", "volatile", "while"];

    isKeyword:  function(k) { return this.keywords.indexOf(k) != -1; }
};


CParser.parse = function(input) {
    return CParser.matchAll(input, 'topLevel');
};

module.exports = CParser
