
/**
 * Copyright (c) 2015 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENSE file at the root of the project for the full license.
 *
 */


// Dependencies
var CParser     = require('../../c/grammars/c_parser.ojs'),
    ES5Parser   = require('../../../deps/es5/grammars/es5_parser.ojs'),
    __          = require('../nodes.js');
var namespace_funcs = [];
var sync_funcs      = [];

/**
 * C side of the JAMScript language..
 * Full definition of the grammar. This one extends the C parser
 */


ometa JAMCParser <: CParser  {

    jdata_type      = ("broadcaster" | "logger" | "shuffler"):s         -> __.JdataType().value(s.value()),
    
    jdata_spec      = ^type_spec:t "Id":i "as" jdata_type:d ";"         -> __.JdataSpec(t, d).name(i.value()),

    jdata_decl      = "jdata" "{" jdata_spec*:s "}"                     -> __.JdataDecl(s),

    namespace_spec  = "in" "Id":s                                       -> __.NamespaceSpec().name(s.value()),

    type_spec       = "jcallback":s                                     -> __.TypeSpec().type(s.value())
                    | ^type_spec,

    async_decl      = "jasync" declarator:d
                                    namespace_spec?:ns                  -> {this.addToNameSpace(d, ns); __.ASyncDeclaration(d, ns)},

    sync_decl       = "jsync" decl_specs:s declarator:d
                                    namespace_spec?:ns                  -> {this.addSyncFunc(d,ns); this.addToNameSpace(d, ns); __.SyncDeclaration(s, d, ns)},

    c_as_activity   = async_decl:d {CParser.setActivity(d);} compound_stmt:s {CParser.clearActivity();}        -> __.ASyncActivityDef(d, s).type("c"),

    js_as_activity  = async_decl:d {ES5Parser.setActivity(d);} ES5Parser.block:b {ES5Parser.clearActivity();}   -> __.ASyncActivityDef(d, b).type("js"),

    c_s_activity    = sync_decl:d {CParser.setSyncActivity(d);} compound_stmt:s {CParser.clearActivity();}                       -> __.SyncActivityDef(d, s).type("c"),

    js_s_activity   = sync_decl:d {ES5Parser.setSyncActivity(d);} ES5Parser.block:b {ES5Parser.clearActivity();}                     -> __.SyncActivityDef(d, b).type("js"),

    async_activity  = c_as_activity
                    | js_as_activity,

    sync_activity   = c_s_activity
                    | js_s_activity,

    activity_def    = sync_activity
                    | async_activity,

    function_def    = activity_def
                    | ^function_def,

    external_decl   = jdata_decl
                    | function_def
                    | declaration,

    program         = external_decl+
}

JAMCParser.addSyncFunc = function(decl, namespace) {
    var funcName = decl[1].name;
    if(namespace != undefined) {
        funcName = namespace[1].name + "." + funcName;
    }
    sync_funcs.push(funcName);
}

JAMCParser.addToNameSpace = function(decl, namespace) {
    if(namespace != undefined) {
        var namespace_name = namespace[1].name;
        if(namespace_funcs.indexOf(namespace_name) == -1) {
            namespace_funcs[namespace_name] = [];
        }
        namespace_funcs[namespace_name].push(decl[1].name);
    }
}

JAMCParser.printCallGraph = function() {
    var graph = 'digraph jamgraph{\n';
    var callList = '';
    if(CParser.callGraph.size > 0) {
        var usedFunctions = new Set();
        graph += 'subgraph cluster_0 {\n';
        graph += 'label = "C Functions";\n'
        CParser.callGraph.forEach(function(calls, func) {
            // graph += func + ';\n';
            if(calls.size > 0) {
                usedFunctions.add(func);
            }
            calls.forEach(function(call) {
                callList += func + ' -> ' + call + ';\n';
                if(CParser.callGraph.has(call)) {
                    usedFunctions.add(call);
                }
            });
        });
        usedFunctions.forEach(function(func) {
            graph += func + ';\n';
        });
        graph += '}\n'
    }
    if(ES5Parser.callGraph.size > 0) {
        var usedFunctions = new Set();
        graph += 'subgraph cluster_1 {\n';
        graph += 'label = "J Functions";\n'
        ES5Parser.callGraph.forEach(function(calls, func) {
            // graph += func + ';\n';
            usedFunctions.add(func);
            calls.forEach(function(call) {
                callList += func + ' -> ' + call + ';\n';
                if(ES5Parser.callGraph.has(call)) {
                    usedFunctions.add(call);
                }
            });
        });
        usedFunctions.forEach(function(func) {
            graph += func + ';\n';
        });
        graph += '}\n'
    }
    
    graph += callList;
    graph += '}';
    return graph;
};


JAMCParser.parse = function(input) {

    // Add JAMScript C side keywords..
    this.spec.addKeywords(["jasync", "jsync", "in", "jdata", "as", "broadcaster", "logger", "shuffler"]);
    this.spec.addTypename("jcallback");
    return {
        tree: JAMCParser.matchAll(input, 'program'), 
        data: {
            'callGraph': JAMCParser.printCallGraph(),
            'cCallbacks': CParser.callbacks,
            'namespace_funcs': namespace_funcs,
            'sync_funcs': sync_funcs
        }
    };
};

module.exports = JAMCParser
