/**
 * Copyright (c) 2015 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENSE file at the root of the project for the full license.
 */

// Dependencies
var CTranslator     = require('../../c/grammars/c_translator.ojs'),
    ES5Translator   = require('../../../deps/es5/grammars/es5_translator.ojs'),
    join            = require('../../../utils.js').join;

var ActivityID         = 0;
var callbacks          = {
                            c:  {
                                  async: [],
                                  sync:  []
                                },
                            js: {
                                  async: [],
                                  sync:  []
                                }
                         };
var typedefs           = [];
var namespace_funcs    = [];

var types           = {
                        'int': {
                            c_pattern: '%i',
                            jamlib: 'ival',
                            js_type: 'number',
                            c_code: 'i',
                            js_code: 'n'
                        },
                        'float': {
                            c_pattern: '%f',
                            jamlib: 'dval',
                            js_type: 'number',
                            c_code: 'f',
                            js_code: 'n'
                        },
                        'char *': {
                            c_pattern: '\\"%s\\"',
                            jamlib: 'sval',
                            js_type: 'string',
                            c_code: 's',
                            js_code: 's'
                        }
                      };
                      
ometa JAMCTranslator <: CTranslator {

    NamespaceSpec    :n = empty                                                     -> n.name(),

    ASyncDeclaration :n = walk:d walk?:na                                           -> this.rules.JDeclaration(this, false, n[2], "jactivity", d, na),

    SyncDeclaration  :n = walk:s walk:d walk?:na                                    -> this.rules.JDeclaration(this, true, n[3], s, d, na),

    CompoundStmt     :n = ?this.context.TarActivityCtx() walk*:d walk*:s            -> this.rules.CompoundStmt(this, d, s)
                        | ^CompoundStmt,

    BlockStmt        :n = ?this.context.TarActivityCtx() ES5Translator.walk*:cs     -> this.rules.BlockStmt(this, cs)
                        | ES5Translator.BlockStmt,

    ASyncActivityDef :n = ?this.context.SetActivityCtx(n) walk:d walk:s             -> this.rules.ASyncActivityDef(this, n.type(), s),

    SyncActivityDef  :n = ?this.context.SetActivityCtx(n) walk:d walk:s             -> this.rules.SyncActivityDef(this, n.type(), s)

}


JAMCTranslator.context = function() {

    var activityID = 0,
        inActivityFlag = false,
        activityCtx;

    return {
        SetActivityCtx: function(q) {
            // TODO: Figure out how to generate trully random strings.
            activityID = Math.random().toString(36).substring(7);
            inActivityFlag = true;
            return true;
        },

        TarActivityCtx: function() {
            // Test and Reset Activity Context
            var flag = inActivityFlag;
            inActivityFlag = false;
            return flag;
        },

        GetActivityID: function() {
            return activityID;
        },

        SaveValToAC: function(val) {
            activityCtx = val;
        },

        GetValFromAC: function() {
            return activityCtx;
        },

        TestActivityCtx: function() {
            return inActivityFlag;
        }
    }
}();

JAMCTranslator.rules = {

    JDeclaration: function(that, sflag, tree, spec, decl, namespc) {
        var funcname = tree[1].name,
            params   = that.helpers.ParamsFromParamDecl(tree);
        var rtype = spec;
        if(tree[1].pointer != undefined) {
            rtype += ' ' + CTranslator.match(tree[1].pointer, 'walk').slice(0, -1); // Last char is space
        }
        if(namespc != undefined) {
            funcname = namespc + "_func_" + namespace_funcs[namespc].indexOf(funcname);
        }
        that.context.SaveValToAC({
            sync: sflag,
            declspec: rtype,
            fname: funcname,
            params: params,
            namespace: namespc
        });
        
        return sflag;
    },

    // d is declarations within the compound statement
    // s is the set of statements
    CompoundStmt: function(that, d, s) {
        return join('{', d.join(''), s.join(''), '}');
    },

    BlockStmt: function(that, cs) {
        return join('{\n', cs.join(';\n'), ';\n', '}');
    },


    ASyncActivityDef: function(that, atype, stmt) {
        var actx = that.context.GetValFromAC();
        var c_output;
        var js_output;
        if(atype == 'c') {
            js_output = that.helpers.CreateCASyncJSFunction(that.context.GetActivityID(), actx.fname, actx.params);
            c_output = that.helpers.CreateCASyncCFunction(actx.declspec, actx.fname, actx.params, stmt);
       } else if (atype == 'js') {
            js_output = that.helpers.CreateJSASyncJSFunction(that.context.GetActivityID(), actx.fname, actx.params, stmt);
            c_output = that.helpers.CreateJSASyncCFunction(that.context.GetActivityID(), actx.fname, actx.params);
        }
        return {
            C: c_output,
            JS: js_output.JS,
            annotated_JS: js_output.annotated_JS
        }
    },

    SyncActivityDef: function(that, atype, stmt) {
        var actx = that.context.GetValFromAC();
        var c_output;
        var js_output;

        if(atype == 'c') {
            js_output = that.helpers.CreateCSyncJSFunction(that.context.GetActivityID(), actx.fname, actx.params);
            c_output = that.helpers.CreateCSyncCFunction(actx.declspec, actx.fname, actx.params, stmt);
        } else if (atype == 'js') {
            js_output = that.helpers.CreateJSSyncJSFunction(that.context.GetActivityID(), actx.declspec, actx.fname, actx.params, stmt);
            c_output = that.helpers.CreateJSSyncCFunction(that.context.GetActivityID(), actx.declspec, actx.fname, actx.params);
        }

        return {
            C: c_output,
            JS: js_output.JS,
            annotated_JS: js_output.annotated_JS
        }
    }
}

JAMCTranslator.helpers = {

    ParamsFromParamDecl: function(tree) {
        var i,
            tempdecs,
            tempdecl,
            collected = [];
        for (i = 2; i < tree.length; i++) {
            tempdecs = tree[i][2];
            tempdecl = tree[i][3];
            var pointer = "";
            if(tempdecl[1]['pointer'] != undefined) {
                pointer = ' ' + CTranslator.match(tempdecl[1]['pointer'], 'walk').trim();
            }
            collected.push({name: tempdecl[1].name, pointer: pointer, type: tempdecs[2][1].type});
        }
        return collected;
    },

    CreateCASyncJSFunction: function(actID, fname, params) {
        var ps = [];
        params.forEach(function(p) {
            ps.push(p.name);
        });
        var funccode = fname + ": " + "function(" + ps.join(',') + ") {";

        // write the code that would call the remote function
        funccode += 'jlib.JServer.remoteAsyncExec(' + fname + '[' + ps.join(',') + '], "true");';

        // write the end of the function
        funccode += "}";

        return {
            JS: funccode,
            annotated_JS: funccode
        }
    },

    CreateCASyncCFunction: function(dspec, fname, params, stmt) {
        var cout = "";
        var typed_params = [];
        var c_codes = [];
        params.forEach(function(p) {
            typed_params.push(p.type + p.pointer + " " + p.name);
            c_codes.push(types[p.type + p.pointer].c_code);
        });

        // Main function
        cout += join('void', ' ', fname, '(', typed_params.join(", ") , ')', stmt);

        // Calling function
        cout += 'void call' + fname + '(void *act, void *arg) {\n';
        cout += 'command_t *cmd = (command_t *)arg;\n';
        cout += fname + '(';
        for (var i = 0; i < params.length; i++) {
            cout += 'cmd->args[' + i + '].val.' + types[params[i].type + params[i].pointer].jamlib
            if(i < params.length - 1 ) {
                cout += ', ';
            }
        }
        cout += ');\n';
        cout += '}\n';
        
        callbacks.c.async.push([fname, undefined, c_codes]);
        return cout;
    },

    CreateCSyncJSFunction: function(actID, fname, params) {
        var ps = [];
        params.forEach(function(p) {
            ps.push(p.name);
        });
        var funccode = fname + ": " + "function(" + ps.join(',') + ") {";

        // write the code that would call the remote function
        funccode += 'jlib.JServer.remoteSyncExec(' + fname + '[' + ps.join(',') + '], "true");';

        // write the end of the function
        funccode += "}";

        return {
            JS: funccode,
            annotated_JS: funccode
        }
    },

    CreateCSyncCFunction: function(dspec, fname, params, stmt) {
        var cout = "";
        var typed_params = [];
        var c_codes = [];
        params.forEach(function(p) {
            typed_params.push(p.type + p.pointer + " " + p.name);
            c_codes.push(types[p.type + p.pointer].c_code);
        });

        // Main function
        cout += join(dspec, ' ', fname, '(', typed_params.join(", ") , ')', stmt, '\n');

        // Calling function
        cout += dspec + ' call' + fname + '(void *act, void *arg) {\n';
        cout += 'command_t *cmd = (command_t *)arg;\n';
        cout += 'return ' + fname + '(';
        for (var i = 0; i < params.length; i++) {
            cout += 'cmd->args[' + i + '].val.' + types[params[i].type + params[i].pointer].jamlib
            if(i < params.length - 1 ) {
                cout += ', ';
            }
        }
        cout += ');\n';
        cout += '}\n';
    
        callbacks.c.sync.push([fname, undefined, c_codes]);
        return cout;
    },


    // Register JS function use 'activityID', 'error', function
    // js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "error");
    CreateJSFunctionHookUp: function(actID, fname, type, namespace, activity) {
        return join("HookUpJSFunction(", actID, activity, fname, type, namespace, ");");
    },

    CreateJSASyncJSFunction: function(actID, fname, params, stmt) {
        var ps = [];
        var annotated_ps = [];
        var js_codes = [];
        var c_codes = [];
        params.forEach(function(p) {
            ps.push(p.name);
            annotated_ps.push(p.name + ':' + types[p.type + p.pointer].js_type);
            js_codes.push(types[p.type + p.pointer].js_code);
            c_codes.push(types[p.type + p.pointer].c_code);
        });
        		
		var jsout = "function " + fname + "(" + ps.join(',') + ")" + stmt;
		var annotated_jsout = "function " + fname + "(" + annotated_ps.join(',') + "): void" + stmt;

        callbacks.js.async.push([fname, js_codes, c_codes]);
        return {
            JS: jsout, 
            annotated_JS: annotated_jsout
        };
    },

    CreateJSASyncCFunction: function(actID, fname, params) {
    	var ps = [], qs = [];
        params.forEach(function(p) {
            ps.push([p.type, p.pointer, p.name].join(' '));
            qs.push(p.name);
        });

    	var cout = "jactivity_t *" + fname + "(" + ps.join(', ') + ") {\n";
    	cout += 'jactivity_t *res = jam_rexec_async(js, "' + fname + '"';
    	if(qs.length > 0) {
    		cout += ',' + qs.join(', ');
    	}
    	cout += ');\n';

    	cout += 'return res;';
    	cout += '}\n';

    	return cout;
    },

    CreateJSSyncJSFunction: function(actID, rtype, fname, params, stmt) {
        var ps = [];
        var annotated_ps = [];
        var js_codes = [];
        var c_codes = [];
        params.forEach(function(p) {
            ps.push(p.name);
            annotated_ps.push(p.name + ':' + types[p.type + p.pointer].js_type);
            js_codes.push(types[p.type + p.pointer].js_code);
            c_codes.push(types[p.type + p.pointer].c_code);
        });
        
        var js_return_type;
 		if(rtype == "void") {
            js_return_type = "void";
        } else {
            js_return_type = types[rtype].js_type;
        }
		
		var jsout = "function " + fname + "(" + ps.join(',') + ")" + stmt;
		var annotated_jsout = "function " + fname + "(" + annotated_ps.join(',') + "):" + js_return_type + stmt;

        callbacks.js.sync.push([fname, js_codes, c_codes]);
        return {
            JS: jsout, 
            annotated_JS: annotated_jsout
        };
    },

    CreateJSSyncCFunction: function(actID, dspec, fname, params) {
    	var ps = [], qs = [];
        params.forEach(function(p) {
            ps.push([p.type, p.pointer, p.name].join(' '));
            qs.push(p.name);
        });

    	var cout = dspec + " " + fname + "(" + ps.join(', ') + ") {\n";
    	cout += 'arg_t *res = jam_rexec_sync(js, "' + fname + '"';
    	if(qs.length > 0) {
    		cout += ',' + qs.join(', ');
    	}
    	cout += ');\n';

    	if(dspec == 'void') {
    		cout += 'return;';
    	} else {
    		cout += 'return res->val.' + types[dspec].jamlib + ';\n';
    	}
    	cout += '}\n';

    	return cout;
    },

    // CreateCallbackEntry(fname, params) {
    //     var js_codes = [];
    //     var c_codes = [];
    //     params.forEach(function(p) {
    //         js_codes.push(types[p.type + p.pointer].js_code);
    //         c_codes.push(types[p.type + p.pointer].c_code);
    //     });
    //     return {
    //             name: fname,
    //             js_code: js_codes,
    //             c_code: c_codes
    //            };
    // },
    
    // create a C stub function.. brand new function.. this is called locally..
    CreateCStubFunction: function(actID, dspec, fname, type, params) {

        var ps = [], qs = [];
        var format_string = "";
        params.forEach(function(p) {
            ps.push([p.type, p.pointer, p.name].join(' '));
            qs.push(p.name);
            // switch(p.type) {
            //     case "int":
            //         format_string += "%d";
            //         break;
            //     case "float":
            //         format_string += "%f"
            //         break;
            // }
            format_string += types[p.type + p.pointer].c_pattern;
        });
        var funccode = dspec + " " + fname + "_" + type + "(" + ps.join(', ') + ") {";

        // Write a C function to create JSON object with the parameters
        // funccode += "JSONObj *j = jsoncreate(" + qs.join(', ') + ");";

        // Write a C function call to make the remote call with the JSON object
        // funccode += "execute_remote_func(app, " + fname + ", " + "j);";
        funccode += 'execute_remote_func(app, "' 
            + fname + '_' + type + '", ' + '"' + format_string +'"';
        if(qs.length > 0) {
            funccode += ',';
        }
        funccode += qs.join(", ") + ');';

        // end
        funccode += "}\n";

        // return the string
        return funccode;
    },


    /**
     * This is a JS function wrapper to call a C function. Uses the same parameter names.
     * The JS function signature is slightly revised one of the C function without the type information.
     * Function name is given
     */
    // Create JavaScript wrapper
    CreateJSWrapperFunction: function(actID, fname, type, params) {
        var ps = [];
        params.forEach(function(p) {
            ps.push(p.name);
        });
        var funccode = fname + "_" + type + ": " + "function(" + ps.join(',') + ") {";

        // write the code that would create the JSON object.
        funccode += "var jobject = {";
        var i = 0;
        params.forEach(function(p) {
            funccode += "arg" + (i++) + ":" + p.name + (i < params.length? "," : "");
        });
        funccode += "};";

        // write the code that would call the remote function
        // funccode += 'execute_remote_func(app, "' + fname + '_' + type + '", ' + '"");';
        funccode += 'socket.write(JSON.stringify({name:"COMPLETE", tag: "' + actID + '", args:[], cback:"xyzwopq"}) + "\\n");';


        // write the end of the function
        funccode += "},";

        return funccode;
    },

    CreateOutput: function(arr) {
        var cout = "";
        var jsout = "";
        var ajsout = "";
        arr.forEach(function(e) {
            if (!!e.C)
                cout += e.C;
            if (!!e.JS)
                jsout += e.JS;
            if (!!e.annotated_JS)
                ajsout += e.annotated_JS;
        });
        return {'C': cout, 'JS': jsout, 'annotated_JS': ajsout};
    }
}


JAMCTranslator.force_rules = false;

JAMCTranslator.generate_js_callbacks = function () {
    var jsout = '';
    for (var i = 0; i < callbacks.js.sync.length; i++) {
        var callback = callbacks.js.sync[i];
        jsout += 'jlib.JServer.registerCallback(' + callback[0] + ', "' + callback[1].join('') + '");\n';
    }
    for (var i = 0; i < callbacks.js.async.length; i++) {
        var callback = callbacks.js.async[i];
        jsout += 'jlib.JServer.registerCallback(' + callback[0] + ', "' + callback[1].join('') + '");\n';
    }
    return jsout;
}

JAMCTranslator.generate_c_activities = function () {
    var cout = '';
    for (var i = 0; i < callbacks.js.sync.length; i++) {
        var callback = callbacks.js.sync[i];
        cout += 'activity_make(js->atable, "' + callback[0] + '", "' + callback[2].join('') + '", SYNC);\n';
    }
    for (var i = 0; i < callbacks.js.async.length; i++) {
        var callback = callbacks.js.async[i];
        cout += 'activity_make(js->atable, "' + callback[0] + '", "' + callback[2].join('') + '", ASYNC);\n';
    }
    for (var i = 0; i < callbacks.c.sync.length; i++) {
        var callback = callbacks.c.sync[i];
        cout += 'activity_regcallback(js->atable, "' + callback[0] + '", "' + callback[2].join('') + '", SYNC, call' + callback[0] + ');\n';
    }
    for (var i = 0; i < callbacks.c.async.length; i++) {
        var callback = callbacks.c.async[i];
        cout += 'activity_regcallback(js->atable, "' + callback[0] + '", "' + callback[2].join('') + '", ASYNC, call' + callback[0] + ');\n';
    }
    return cout;
}

JAMCTranslator.generate_jam_run_app = function(namespace_funcs) {
    var cout = '\nvoid jam_run_app(void *arg) {\n';
    cout += 'user_main();\n'
    cout += '}\n';
    return cout;
}

JAMCTranslator.generate_setup = function(namespace_funcs) {
    var cout = '\nvoid user_setup() {\n';
    cout += this.generate_c_activities();
    cout += '}\n';
    return cout;
}

JAMCTranslator.generate_taskmain = function() {
    var cout = '\nvoid taskmain(int argc, char **argv) {\n
        js = jam_init();
        user_setup();
         
        taskcreate(jam_event_loop, js, STACKSIZE);
        taskcreate(jam_run_app, js, STACKSIZE);
    }';
    return cout;
}


JAMCTranslator.generate_namespace_structs = function() {
    var cout = "";
    var index = 0;
    for (namespace in namespace_funcs) {
        cout += "typedef struct namespace" + index + "{\n";
        for (var i = namespace_funcs[namespace].length - 1; i >= 0; i--) {
            cout += "\tint (*" + namespace_funcs[namespace][i] + ")();\n";
        }
        cout += "} namespace" + index + ";\n";
        cout += "namespace" + index + " " + namespace + ";\n";
        index++;
    }
    return cout;
}

JAMCTranslator.link_namespace_funcs = function() {
    var cout = "";
    for (namespace in namespace_funcs) {
        for (var i = namespace_funcs[namespace].length - 1; i >= 0; i--) {
            cout += "\t" + namespace + "." + namespace_funcs[namespace][i] + " = " + namespace + "_func_" + i + ";\n";
        }
    }
    return cout;
}

JAMCTranslator.parse_typedef = function(input) {
    var name = input[3][2][1].name;
    var type_list = [];
    for (var i = input[2].length - 1; i >= 3; i--) {
        type_list.push(input[2][i][1].type);
    };
    typedefs[name] = type_list;
}

JAMCTranslator.parse_struct = function(input) {
    var members = input[2][3][2];
    if(members.length > 2) {
        var error = false;
        var jsout = 'type ' + input[3][2][1]['name'] + ' = {';
        for (var i = members.length - 1; i >= 2; i--) {
            var name = members[i][3][2][1]['name'];
            var type = members[i][2][2][1]['type'];

            if(types[type]) {
                jsout += name + ": " + types[type]['js_type'] + "; ";
            } else {
                error = true;
                break;
            }
        };
        jsout += '};\n';
        if(error) {
            return "";
        } else {
            return jsout;   
        }
    } else {
        return "";
    }
}


JAMCTranslator.translate = function(input) {
    namespace_funcs = input.data.namespace_funcs;
    var tree = input.tree;
    var cout = "";
    var jsout = "";
    var annotated_JS = "";

    var struct_objects = "";
    var typedefs = [];
    // var appDeclared = false;
    
    for(var i=0; i<tree.length; i++) {
        if(tree[i][0] == 'SyncActivityDef' || tree[i][0] == "ASyncActivityDef") {
            // if(!appDeclared) {
            //     cout += "Application *app = ((void *)0);\n";
            //     cout += "int wait_var = 0;\n";
            //     cout += this.generate_namespace_structs();
            //     appDeclared = true;
            // }
            output = JAMCTranslator.match(tree[i], 'walk');
            cout += output.C + "\n";
            jsout += output.JS + "\n"; 
            annotated_JS += output.annotated_JS + "\n";
        } else {
            // Type Checking Stuff
            // if(tree[i][2][3] != undefined && tree[i][2][3][0] == "TypeSpec") {
            //     if(tree[i][2][3][2] != undefined) {
            //         if(tree[i][2][3][2][0] == "StrucSpec") {
            //             struct_objects += this.parse_struct(tree[i]);
            //         }
            //     } else {
            //         typedefs = this.parse_typedef(tree[i]);
            //     }
            // }

            cout += CTranslator.match(tree[i], 'walk') + "\n";
            // cout += CTranslator.translate(tree[i], input.data.sync_funcs)
        } 
    }
    cout += this.generate_setup();
    cout += this.generate_jam_run_app();
    cout += this.generate_taskmain();
    jsout += this.generate_js_callbacks();
    annotated_JS = "/* @flow */\n" + struct_objects + annotated_JS + this.generate_js_callbacks();

    return {'C': cout, 'JS': jsout, 'annotated_JS': annotated_JS};
};

module.exports = JAMCTranslator;
