

======================== DONE UP TO HERE =============================

Embed the conditional into the command structure
    = Encoding
    = Decoding

Revise the JavaScript side 
Test the embedding and get old programs working

We need an API or structure for JCond execution. This needs to be 
formulated so that JData works with it.

Inform Ross about the API. His API needs to be compatible (similar) with
this one.

C to J Asynchronous

    = Pass the execution from bottom up
    = No need to send all the levels a simultaneous execution request. 
      This should simplify the execution flow for the program.

C to J Synchronous

    = Contact the root of the sub machine. If the root is unable to execute we fail.
    = Once the root executes, we ask the rest of the machine to execute.

Test disconnection tolerance
Test performance and scaling


Conditional execution of the two C to J variations
    = We need to cover the conditional execution of the two variations.

J to C Asynchronous


J to C Synchronous

Conditional execution of the two J to C variations


Test scaling
Test synchronization

=====================

PROBLEM #1
Do we have a clock pile up problem?
= If so, how do we solve that problem? 
    How is this solution?
        = Generate the High clock interrupt. 
        = At the second pending interrupt, disable the interrupt generation
        = When a pending interrupt goes to service, enable interrupt generation

PROBLEM #2
Check whether a particular condition is specified as part of jConditional
= We actually use a bit vector to denote the conditions that are encoded
  in the conditional. User conditions (jData) are generic yes/no. 
  sys parameters are encoded one-by-one. 

  Elaborated below??


@JAMWorker
    = Check all arguments
    = Check conditions: 
        if synchronization requested
            enqueue for next synchronized execution slot with the
                given amount of synchronization
        else
            if no synchronized requests already in queue 
                perform immediate execution of the task otherwise
            else
                enqueue the request for next synchronized execution slot 

@JAMEventloop
    = Get the event (packet) to be processed
    = If the event is a sync timeout and we have a sync task
        = get the sync threshold
        = if we can synchronize to the threshold
                run the task
          otherwise 
                drop the task
    = end 

@Activity (runActivityLoop)
    == Save the results in the runactivity table?? We should keep the results there
       remove it using the LRU algorithm
    == Publish the results if synchronous execution

If the results did not reach the other side, there could be a query.
Look up the runactivity table to answer the query. It could be still running
or the results available.


================
Why broadcasting?

This will allow the cloud/fog to setup the state of the devices.
The devices can sample the broadcast memory at any time. They get the value that is there.
The only way to synchronize the update is to put a JCondition check at the function 
invocation. This will ensure that the function is invoked only after the update has taken
place.


===============
Resolve the mess in the JActivity

jactivity is created as follows:
    = created for the main thread - main program - this 
        used to run the program and all the synchronous functions
    = created for each asynchronous functions

    = created for each remote function call 

jactivity is deleted as follows:
    = main thread is only deleted when the program is terminated 
    = asynchronous functions - deleted by the user program 

    = deleted by the remote function call 

What happens at creation?
    = Allocate memory for the activity structure
    = Get a free thread from the pool 
    = Set the thread to the activity 
    = Activity ID should be set in both thread and activity structures
    = State is set to NEW in the activity 

What happens at deletion?
    = Disassociate the thread from the activity: needs to be done in the thread and activity 
    = Release activity ID by releasing the memory and setting the pointer to NULL

Main thread needs a activity.
Each asynchronous function invocation needs a activity
Synchronous functions run in the main thread

Remote calls run in their own activities.

Each activity gets its own activity thread and the corresponding input and output queues.

We use the runtable entries to maintain the state of an execution. 

The runtable entries are used to keep track of what is pending.

== J to C executions: state of the local executions so that remote side can query
== C to J executions: as a temporary state store 

=============================
Gang (group) Scheduling algorithm

The execution of all the machines are split into time slots. 
I mean the timeline is divided into lets say 1 second slots like 
a time sharing algorithm.
We assume tightly synchronized clocks for now. We could use our group 
scheduling algorithm to check whether the clocks are actually synchronized.

1)  Lets say we mark every n-th slot as possible synchronization slot. That is,
    during this slot, all the nodes synchronize with each other. The way they
    synchronize would be very simple: they talk to the leader in the tree. By 
    talking to the leader they should be able to determine whether the required
    number of nodes have reached the synchronization point. The synchronization 
    point is a success if the required threshold of nodes have arrived at the slot.

2)  We have a mix of tasks to run in the system of machines. Some of these machines
    can disconnect and reconnect during the execution of the program. The mix of
    tasks include asynchronous and synchronous ones. The synchronous ones ask several
    nodes to execute the components at the same time. That means the machines have to
    all run the same task. However, we could have a threshold where we say that at least
    8 machines need to show up to execute a particular task. 
    
3)  So here is a dynamic algorithm for synchronous execution. There are no schedules
    in this scenario. A message is sent to execute a certain task (function) at
    each node. With the synchronous case, we could have multiple tasks required to run
    at different nodes at the same time. 
    
    
        A leaf node receives an execution request for a SyncTask. 
        SyncTask includes a quorum indicating the minimum number of nodes required for execution.
        
        If next available SyncSlot is free
            Schedule the SyncTask at the next SyncSlot
        else 
            If the required quorum of the SyncTask > required quorum of the next SyncSlot &&
                pending SyncTasks < N 
                Schedule the SyncTask right after the current SyncTask
            else
                Schedule the SyncTask in the SyncSlot after the next one 

        At SyncSlot time we do the following:
            synchronize with the other nodes using the J node 

        If synchronization achieved (pending SyncTasks exchanged)
            execute the queued tasks                
        else 
            delay the SyncTasks execution to the next SyncSlot 
