
= Simple mycontext
= Activity struct as described below
= Remote exec.. as described below



Plans March 8, 2016
===================

IMPORTANT: Do we restrict activities such that there is no recursive calls?
Activity X cannot call X again either directly or indirectly.


C-core calling J-core

= Marshall the parameters
= Get the activity ID
= Stick the activity ID in the request for remote execution
= Activity state = NEW

= Send the remove execution request. Wait for acknowledgement.
= Once we receive the acknowledgment, make
    Activity state = RUNNING
  If we fail to get the ack after many tries, make
    Activity state = TIMEDOUT

= Get the lease time from the ack from the remote side

= Add a timer call for the activity

= When we receive a timer expiry, we check the health
    of the corresponding activity.
    If the activity health check fails, we timeout
    the execution of the activity with a failure.

============= Challenge!!

= If the activity is synchronous, we need to wait
    for one of the following conditions:
        = timeout failure of the activity execution
        = successful completion of the activity
        = erroneous run of the activity - similar to the timeout

= If the activity is asynchronous, we don't wait
......???

Asynchronous .. what do we do?
        = we have the user program running..
        = "yield" routines are embedded in the user program
        = yield checks for background executions.. after checking we always
            return back to the main thread

wait for asynchronous activity
    = is a yield statement, where we yield the user execution
        until we have a "reply" of some sort for the activity

The only difference between the two: sync and async
    = sync we call the yield as soon as we complete the invocation

We need to develop a "yield" or context switch routine.
    = Need to ensure that this is built on non deprecated functions




==========

activitytable_t *at = activity_table_new();

activity_t *act = activity_get_id(activitytable_t *atbl, char *actname);

activity_start(activity_t *act);
activity_stop(activity_t *act, void *code);






















New Plans
=========

= Get CBOR working from C side:
    = Create a routine for encoding a command and print it to the screen.
    = Retrieve standard input (file redirect) and decode the CBOR and
        retrieve the command.
    (The second one responsible for retrieving network data and
    recovering the command.)

= Use the nanomsg and rewrite the Socket routines in the previous jamlib.

= C->JS transfers through CBOR
= JS->C transfer through CBOR

= C->JS & JS->C working with CBOR and nanomsg

Modify the jamlib routines to work with the new combination
    = CBOR
    = nanomsg

Improve the jamlib to the new architecture
    = Fog
    = Cloud
    = Handle fault tolerance

Activity logging with new jamlib

Activity accumulation to the cloud central


NOTE 1: Rethink the use of assert(). We need something that would implement
assert differently and also log the important events.

NOTE 2: Should logging or the direction of message flow be part of the command?



Old Plans
=========




Respond to Ping
    This could be a heartbeat for a running request too.

Respond to Survey
    A request to run an activity comes through the survey.

    A heartbeat request for running activity comes through the survey

    Are you there type of queries come through survey

Get Subscriptions
    This could be triggering some local callbacks on the pub-sub messages.


Fog server holds all the sockets..
    including the REQREP ones!

Step 1:
=======
First the list of FOG_SERVERs are tried and then CLOUD_SERVERs are attempted.

If the FOG_SERVER is found, we should get the config information from that
server.

CLOUD_SERVER has a all-Fog registry. Send a survey to that address seeking
a Fog for for the application we are running right now... given by
APP_NAME

= Perform survey
= Perform request and expect result

= Process survey
= Process request
= Process publish

Step 2:
=======
Register the c-core with the Fog so that the c-core could respond to the
surveys send out by the Fog server.


Step 3:
=======
Run a J-core activity. Activity we need to ask the J-core to run for the C-core.
Reliability management is big part of the execution protocol. We also need to make sure
that the protocol does not depend on the run time of the application so we
can use timeouts in a sane manner.

Step 4:
=======
Run a C-core activity.
