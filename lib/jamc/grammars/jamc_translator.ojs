/**
 * Copyright (c) 2015 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENSE file at the root of the project for the full license.
 */

// Dependencies
var CTranslator  = require('../../c/grammars/c_translator.ojs'),
    ES5Translator = require('../../../deps/es5/grammars/es5_translator.ojs'),
    join         = require('../../../utils.js').join,
    escape       = require('../../../utils.js').escape_string;

var ActivityID   = 0;

ometa JAMCTranslator <: CTranslator {

    NamespaceSpec :n = empty                                                            -> n.name(),

    JDeclaration :n = walk?:s walk:d walk?:na                                           -> this.rules.JDeclaration(this, n.sync(), n[3], s, d, na),

    ODeclaration :n = walk:d                                                            -> this.rules.ODeclaration(n.type(), d),

    CompoundStmt :n = ?(this.context.TarActivityCtx()) walk*:d walk*:s                  -> this.rules.CompoundStmt(d, s)
                    | ^CompoundStmt,

    BlockStmt    :n = ?(this.context.TarActivityCtx()) ES5Translator.walk*:cs           -> this.rules.BlockStmt(cs)
                    | ES5Translator.BlockStmt,

    CompleteBlock :n =  walk:d ES5Translator.walk:s                                     -> this.rules.CompleteBlock(d, s),

    ErrorBlock   :n = walk:d ES5Translator.walk:s                                       -> this.rules.ErrorBlock(d, s),

    CompleteStmt :n = walk:d walk:s                                                     -> this.rules.CompleteStmt(d, s),

    ErrorStmt    :n = walk:d walk:s                                                     -> this.rules.ErrorStmt(d, s),

    CancelStmt   :n = walk:d walk:s                                                     -> this.rules.CancelStmt(d, s),

    VerifyStmt   :n = walk:d walk:s                                                     -> this.rules.VerifyStmt(d, s),

    ActivityDef  :n = ?(this.context.SetActivityCtx()) walk:j walk:s
                        walk?:cs walk?:es walk?:cas walk?:vs                            -> this.rules.ActivityDef(n.type(), j, s, cs, es, cas, vs)
}


JAMCTranslator.context = function() {

    var activityID = 0,
        inActivityFlag = false,
        activityCtx;

    return {
        SetActivityCtx: function() {
            // TODO: Figure out how to generate trully random strings.
            activityID = Math.random().toString(36).substring(7);
            inActivityFlag = true;
            return true;
        },

        TarActivityCtx: function() {
            // Test and Reset Activity Context
            var flag = inActivityFlag;
            inActivityFlag = false;
            return flag;
        },

        GetActivityID: function() {
            return activityID;
        },

        SaveValToAC: function(val) {
            activityCtx = val;
        },

        GetValFromAC: function() {
            return activityCtx;
        },

        TestActivityCtx: function() {
            return inActivityFlag;
        }
    }
}();

JAMCTranslator.rules = {

    JDeclaration: function(that, sflag, tree, spec, decl, namespc) {

        var funcname = tree[1].name,
            params   = that.helpers.ParamsFromParamDecl(tree);

        that.context.SaveValToAC({
            sync: sflag,
            fname: funcname,
            params: params,
            namespace: namespc
        });

        return sflag;
    },

    ODeclaration: function(that, otype, decl) {

        return join(otype, ' ', decl);
    },

    // d is declarations within the compound statement
    // s is the set of statements
    CompoundStmt: function(that, d, s) {
        var c_output = "",
            js_output = "",
            actx = that.context.GetValFromAC();

        // create JavaScript wrapper
        js_output += that.helpers.CreateJSWrapperFunc(actx.fname, actx.params);

        // create C function - just need to revise the declaration.. rest is OK
        c_output += that.helpers.CreateCFunction(actx.fname, actx.params, join('{', d, s, '}'));

        // register the C function callback
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "activity");

        // Return object containing both C and JS components
        return {
            C: c_output,
            JS: js_output
        }
    },

    BlockStmt: function(that, cs) {
        var c_output = "",
            js_output = "",
            actx = that.context.GetActivityCtx();

        // create JavaScript function - just need to change the function declaration from C to JS
        js_output += that.helpers.CreateJSFunction(actx.fname, actx.params, join('{', cs, '}'));

        // create command hooking up JS function
        js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "activity");

        // create a C stub function.. brand new function.. this is called locally..
        c_output += that.helpers.CreateCStubFunction(actx.fname, actx.params);

        return {
            C: c_output,
            JS: js_output
        }
    },

    CompleteBlock: function(that, odecl, block) {
        var js_output = "",
            actx = that.context.GetActivityCtx();

        // create the JavaScript function .. only C function declaration needs to change
        js_output += that.helpers.CreateJSFunction(actx.fname, actx.params, block);

        // Register JS function use 'activityID', 'complete', function
        js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "complete");

        // return the code object..
        return {
            C: undefined,
            JS: js_output
        }
    },

    ErrorBlock: function(that, odecl, block) {
        var js_output = "",
            actx = that.context.GetActivityCtx();

        // create the JavaScript function .. only C function declaration needs to change
        js_output += that.helpers.CreateJSFunction(actx.fname, actx.params, block);

        // Register JS function use 'activityID', 'error', function
        js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "error");

        // return the code object..
        return {
            C: undefined,
            JS: js_output
        }
    },

    CompleteStmt: function(that, odecl, stmt) {
        var c_output = "",
            actx = that.context.GetActivityCtx();

        // create the C function.. only slight revision of the function declarator
        c_output += that.helpers.CreateCFunction(actx.fname, actx.params, stmt);

        // register C function callback.. activityID, "complete", function
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "complete");

        // return the code object..
        return {
            C: c_output,
            JS: undefined
        }
    },

    ErrorStmt: function(that, odecl, stmt) {
        var c_output = "",
            actx = that.context.GetActivityCtx();

        // create the C function.. only slight revision of the function declarator
        c_output += that.helpers.CreateCFunction(actx.fname, actx.params, stmt);

        // register C function callback.. activityID, "error", function
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "error");

        // return the code object..
        return {
            C: c_output,
            JS: undefined
        }
    },

    CancelStmt: function(that, odecl, stmt) {
        var c_output = "",
            actx = that.context.GetActivityCtx();

        // create the C function.. only slight revision of the function declarator
        c_output += that.helpers.CreateCFunction(actx.fname, actx.params, stmt);

        // register C function callback.. activityID, "cancel", function
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "cancel");

        // return the code object..
        return {
            C: c_output,
            JS: undefined
        }
    },


    VerifyStmt: function(that, odecl, stmt) {
        var c_output = "",
            actx = that.context.GetActivityCtx();

        // create the C function.. only slight revision of the function declarator
        c_output += that.helpers.CreateCFunction(actx.fname, actx.params, stmt);

        // register C function callback.. activityID, "verify", function
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "verify");

        // return the code object..
        return {
            C: c_output,
            JS: undefined
        }
    },


    /** Activity matrix
     * C - sync     :   C statement, -, -, -, -
     * C - async    :   C statement, JS complete, JS error, C cancel, C verify
     * JS - sync    :   JS block, -, -, -, -
     * JS - async   :   JS block, C complete, C error, -, -
     */

    ActivityDef: function(atype, jdecl, stmt, cmpstmt, errstmt, cnclstmt, vrfystmt) {
        var c_output = "",
            js_output = "",
            actx = that.context.GetValFromAC();

        // Enforce consistency conditions.. c/js.. sync/async
        // Generate the code and return C/JS components of the generated source
        if (atype == "c") {
            // Primary block is C..
            if (jdecl) {
                // sync C block
                if (!cmpstmt.c_output && !errstmt.c_output && !cnclstmt.c_output && !vrfystmt.c_output) {
                    c_output += stmt.c_output;
                    js_output += stmt.js_output;
                } else {
                    console.log("ERROR! Only a primary block with synchronous activity");
                    // TODO: need to exit
                }
            } else {
                // async C block


            }
        } else {
            if (jdecl) {

            } else {

            }
        }
        console.log("C_output: ", c_output, "JS_output ", js_output);

        return {
            C: c_output,
            JS: js_output
        }
    }
}


JAMCTranslator.helpers = {

    ParamsFromParamDecl: function(tree) {
        var i,
            tempdecs,
            tempdecl,
            collected = [];

        for (i = 2; i < tree.length; i++) {
            tempdecs = tree[i][2];
            tempdecl = tree[i][3];
            collected.push({name: tempdecl[1].name, pointer_level: tempdecl[1].pointer_level, type: tempdecs[2][1].type});
        }
        return collected;
    },

    // register C function callback.. activityID, "verify", function
    // c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "verify");
    CreateCallBackHookUp: function() {

    },

    // create the C function.. only slight revision of the function declarator
    // c_output += that.helpers.CreateCFunction(actx.fname, actx.params, stmt);
    CreateCFunction: function() {

    },

    // create the JavaScript function .. only C function declaration needs to change
    js_output += that.helpers.CreateJSFunction(actx.fname, actx.params, block);
    CreateJSFunction: function() {

    },

    // Register JS function use 'activityID', 'error', function
    js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "error");
    CreateJSFunctionHookUp: function() {

    },

    // create a C stub function.. brand new function.. this is called locally..
    c_output += that.helpers.CreateCStubFunction(actx.fname, actx.params);
    CreateCSStubFunction: function() {

    },

    // create JavaScript wrapper
    js_output += that.helpers.CreateJSWrapperFunc(actx.fname, actx.params);
    CreateJSWrapperFunction: function() {

    }
}


JAMCTranslator.force_rules = false;
JAMCTranslator.translate = function(input) {
    return JAMCTranslator.match(input, 'walk');
};

module.exports = JAMCTranslator;
