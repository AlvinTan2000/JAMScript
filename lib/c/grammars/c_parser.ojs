
/**
 * Copyright (c) 2015 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENSE file at the root of the project for the full license.
 *
 * This parser borrows quite liberally from the awesome ES5Parser built by
 * Jonathan Brachth√§user (http://b-studios.de). But, don't worry this implements
 * a C grammar and not a JavaScript grammar as ES5!
 */


// Dependencies
var __          = require('../nodes.js');
var symbolTable = require('../symbolTable.js');

/**
 * Reduced C: This parser accepts a subset of the C language.
 * I want to get the JAMScript up and running to hash out the many problems we
 * would encounter in deploying a 'bridge' language and understand what we could do
 * with it.
 *
 * Simplifications:
 * - only basic pointer patterns
 * - no suffix for constants like integers or floats
 * - no prefix for strings
 * - need to check with the full C95 specification for other omissions
 */

var functions = new Map();
var callbacks = new Map();
var jcallbacks = new Set();
var sTable = new symbolTable();
var callGraph = new Map();
var currentFunction = "";
var calls = new Set();


ometa CParser  {

    // Helper Rules
    //
    isKeyword :x    = ?this.spec.isKeyword(x),
    isTypename :x   = ?this.spec.isTypename(x),
    nameFirst       = ^letter | '_',
    nameRest        = nameFirst | ^digit,
    linebreak       = '\n',


    // Comments
    //
    comment         = ``//'' (~linebreak char)* &linebreak
                    | fromTo('/*', '*/'),

    space           = ^space | comment | linebreak,
    spacesNoNl      = (~linebreak space)*,

    // Identifiers and Names
    //
    iName           = <nameFirst nameRest*>,
    id              = iName:name ~isKeyword(name) ~isTypename(name)  -> __.Id(name),
    keyword         = iName:kwd isKeyword(kwd)                       -> __.Keyword(kwd),
    typename        = iName:kwd isTypename(kwd)                      -> __.Typename(kwd),

    // Numeric Literals
    //
    hexDigit        = ^digit | range('a', 'f') | range('A', 'F'),
    hex             = <(``0x''|``0X'') hexDigit+>:d ('u'|'U')? ('l'|'L')? ('l'|'L')?    -> __.Number(parseInt(d)).kind('hex'),

    octalDigit      = range('0', '7'),

    decimalInt      = '0' | (~'0' digit) digit*,
    expPart         = ('e' | 'E') ('+' | '-')? digit+,

    octal           = <'0' octalDigit+>:d ('l'|'L')?                            -> __.Number(parseInt(d,8)).kind('oct'),

    decimal         = decimalValue:f ('l'|'L')                                  -> __.Number(f).kind('double')
                    | decimalValue:f ('f'|'F')?                                 -> __.Number(f).kind('float'),

    decimalValue    = <'-'? decimalInt expPart>
                    | <'-'? decimalInt? '.' digit+ expPart?>,


    integer         = <'-'? decimalInt>:d ('l'|'L')?                            -> __.Number(parseInt(d)).kind('int'),

    charLit         = '\'' '\\' <octalDigit octalDigit? octalDigit?>:cs '\''    -> __.Number(cs).kind('char_oct')
                    | '\'' '\\' 'x' <(~'\'' hexDigit)+>:cs '\''                 -> __.Number(cs).kind('char_hex')
                    | '\'' escapeChar:cs   '\''                                 -> __.Number(cs).kind('char_escape')
                    | '\'' <(~'\'' char)*:cs> '\''                              -> __.Number(cs).kind('char'),

    number          = charLit | hex | octal | decimal | integer,

    // String Literals
    //
    escapeChar      = <'\\' char>:c                                 -> unescape(c),

    string          = '"' (escapeChar | ~'"' char)*:cs '"'          -> __.String(cs.join(''))
                    | ('#' | '`') iName:n                           -> __.String(cs.join('')),

    // Punctuator symbols
    //
    punctuator      = ( ``...'' | ``>>='' | ``<<='' | ``+='' | ``-=''
                    | ``*='' | ``/='' | ``%='' | ``&='' | ``^=''
                    | ``|='' | ``>>'' | ``<<'' | ``++'' | ``--''
                    | ``->'' | ``&&'' | ``||'' | ``<='' | ``>=''
                    | ``=='' | ``!='' | ';' | '{' | '}' | ','
                    | ':' | '=' | '(' | ')' | '[' | ']' | '.'
                    | '&' | '!' | '~' | '-' | '+' | '*' | '/'
                    | '%' | '<' | '>' | '^' | '|' | '?'):s           -> __.Punctuator(s),


    token :tt       = spaces ( ( punctuator | keyword):t ?(t.value() == tt)      -> t
                    | (id | number | string | typename):t ?(t[0] == tt)          -> t
                    ),


    // Expressions
    //
    // TODO: arg_expr_list .. is it just an alias to expression?
    // FIXME: There could be a difference due to semantics..

    listof :p       = apply(p):x ("," apply(p))*:y                  -> {y.unshift(x); y},

    expr            = listof(#assign_expr):le                       -> (le.length > 1? __.SequenceExpr(le) : le[0]),


    assign_expr     = unary_expr:lhs assign_op:op assign_expr:rhs   -> __.AssignExpr(lhs, rhs).operator(op.value())
                    | cond_expr,

    cond_expr       = lor_expr:e "?" expr:t ":" cond_expr:f         -> __.CondExpr(e, t, f)
                    | lor_expr,


    // Binary operations
    //
    lor_expr        = lor_expr:x "||" lar_expr:y                    -> __.BinaryExpr(x, y).operator("||")
                    | lar_expr,
    lar_expr        = lar_expr:x "&&" ior_expr:y                    -> __.BinaryExpr(x, y).operator("&&")
                    | ior_expr,
    ior_expr        = ior_expr:x "|" xor_expr:y                     -> __.BinaryExpr(x, y).operator("|")
                    | xor_expr,
    xor_expr        = xor_expr:x "^" and_expr:y                     -> __.BinaryExpr(x, y).operator("^")
                    | and_expr,
    and_expr        = and_expr:x "&" eq_expr:y                      -> __.BinaryExpr(x, y).operator("&")
                    | eq_expr,
    eq_expr         = eq_expr:x ( "==" | "!=" ):op rel_expr:y       -> __.BinaryExpr(x, y).operator(op.value())
                    | rel_expr,
    rel_expr        = rel_expr:x ( "<=" | "<"
                                    | ">=" | ">"):op shift_expr:y   -> __.BinaryExpr(x, y).operator(op.value())
                    | shift_expr,
    shift_expr      = shift_expr:x ( "<<" | ">>" ):op add_expr:y    -> __.BinaryExpr(x, y).operator(op.value())
                    | add_expr,
    add_expr        = add_expr:x ( "+" | "-" ):op mult_expr:y          -> __.BinaryExpr(x, y).operator(op.value())
                    | mult_expr,
    mult_expr       = mult_expr:x ( "*" | "/" | "%" ):op prefix_expr:y -> __.BinaryExpr(x, y).operator(op.value())
                    | prefix_expr,

    assign_op       = "=" | "*=" | "/=" | ">>=" | "<<=" | "+=" | "-="
                    | "%=" | "&=" | "|=" | "^=",


    // Unary operators
    //

    //
    prefix_expr     = ( "++" | "--" ):op spacesNoNl unary_expr:e    -> __.UpdateExpr(e).operator(op.value())
                    | cast_expr                                     
                    | unary_expr,

    //
    unary_expr      = ( "&" | "*" | "+" | "-"
                            | "~" | "!" ):op prefix_expr:e          -> __.UnaryExpr(e).operator(op.value())
                    | "sizeof" unary_expr:e                         -> __.UnaryExpr(e).operator("sizeof")
                    | "sizeof" "(" type_name:t ")"                  -> __.UnaryExpr(t).operator("sizeof")
                    | postfix_expr,

    cast_expr       = unary_expr
                    | "(" type_name:t ")" cast_expr:e               -> __.CastExpr(t, e),

    postfix_expr    = left_expr:e spacesNoNl ( "++" | "--" ):op     -> __.UpdateExpr(e).operator(op.value()).prefix(false)
                    | left_expr,

    left_expr       = left_expr:p call_expr(p)
                    | left_expr:p member_expr(p)
                    | primary_expr,

    call_expr :p    = "(" listOf(#assign_expr, ","):as ")"          ->  {
                                                                        calls.add(p.value());
                                                                        for (var i = 0; i < as.length; i++) {
                                                                            var element = as[i];
                                                                            if(element[0] == 'Id' && functions.has(element.value())) {
                                                                                callbacks.set(element.value(), functions.get(element.value()));
                                                                            }
                                                                        }
                                                                        __.CallExpr(p, as)
                                                                        },

    member_expr :p  = ( "[" expr:e "]"                              -> __.MemberExpr(p, e)
                        |   "." "Id":i                              -> __.MemberExpr(p).name(i.value())
                        |   "->" "Id":i                             -> __.PointerExpr(p).name(i.value())
                      ),

    primary_expr    = "Id"
                    | "Number"
                    | "String"
                    | "(" expr:e ")"                                -> __.GroupExpr(e),

    const_expr      = cond_expr:e                                   -> e,

    // Declaration statements
    // Statements that do "type" specification
    //
    
    declaration     = decl_specs:ds init_decl_lst:idec ";"          -> {
                                                                            if((ds[2].hasType(#StorageClassSpec) && ds[2].class() === #typedef)) {
                                                                                if(idec == undefined || idec.length == 0) {
                                                                                    if(ds[ds.length-1].hasType(#TypeSpec)) {
                                                                                        // Do type check here for matching type?
                                                                                    }
                                                                                } else {
                                                                                     this.spec.addTypename(idec[0][2].name());
                                                                                }
                                                                            }
                                                                            __.Declaration(ds, idec)
                                                                        },

    decl_specs      = (store_cl_spec | func_spec | type_spec | type_qualifier | gcc_decl_spec)+:s   -> __.DeclSpec(s),

    init_decl_lst   = listOf(#init_decl, ","),

    init_decl       = declarator:d "=" initializer:i                    -> __.InitDecl(d, i)
                    | declarator:d                                      -> __.InitDecl(d),

    type_name       = spec_qual_list:s abs_declarator?:ad               -> __.TypeName(s, ad),

    store_cl_spec   = ("typedef" | "extern" | "static"
                    | "auto" | "register"):s                            -> __.StorageClassSpec().class(s.value()),

    type_spec       = ("void" | "_Bool" | "char" | "short" 
                    | "int" | "long" | "float" | "double" 
                    | "signed" | "unsigned"):s                          -> __.TypeSpec().type(s.value())
                    | enum_spec:e                                       -> __.TypeSpec(e).type("enum")
                    | struct_spec:e                                     -> __.TypeSpec(e).type("struct")
                    | union_spec:e                                      -> __.TypeSpec(e).type("union")
                    | "Typename":t                                      -> __.TypeSpec().type(t.value()),

    struct_spec     = "struct" gcc_attribute* ("Id"|"Typename"):s "{" struct_decl+:l "}"   -> __.StrucSpec(l).name(s.value())
                    | "struct" gcc_attribute* ("Id"|"Typename"):s                          -> __.StrucSpec().name(s.value())
                    | "struct" gcc_attribute* "{" struct_decl+:l "}"                       -> __.StrucSpec(l),

    union_spec      = "union" gcc_attribute* ("Id"|"Typename"):s "{" struct_decl+:l "}"    -> __.UnionSpec(l).name(s.value())
                    | "union" gcc_attribute* ("Id"|"Typename"):s                           -> __.UnionSpec().name(s.value())
                    | "union" gcc_attribute* "{" struct_decl+:l "}"                        -> __.UnionSpec(l),
        
    struct_decl     = spec_qual_list:s listOf(#sdeclarator, ","):l ";"                     -> __.StrucDecl(s,l),

    spec_qual_list  = (type_spec | type_qualifier | gcc_decl_spec)+:l                      -> __.SpecQList(l),

    sdeclarator     = declarator:d ":" const_expr:e gcc_attribute*                         -> __.SDeclarator(d, e)
                    | declarator:d                                                         -> __.SDeclarator(d)
                    | ":" const_expr:e gcc_attribute*                                      -> __.SDeclarator(e),

    enum_spec       = "enum" gcc_attribute* "Id":s "{" listOf(#enumerator, ","):e ","? "}" -> __.EnumDeclaration(e).name(s.value())
                    | "enum" gcc_attribute* "Id":s                                         -> __.EnumDeclaration().name(s.value())
                    | "enum" gcc_attribute* "{" listOf(#enumerator, ","):e ","? "}"        -> __.EnumDeclaration(e),

    enumerator      = "Id":s "=" const_expr:e                                              -> __.Enumerator(e).name(s.value())
                    | "Id":s                                                               -> __.Enumerator().name(s.value()),


    type_qualifier  = ("const"
                    | "restrict"
                    | "__restrict"
                    | "__restrict__"
                    | "volatile"):e                                                      -> __.TypeQual().type(e.value()),

    declarator      = pointer_list:p dir_declarator:d gcc_asm_expr? gcc_attribute*       -> { d.pointer(p); d }
                    | dir_declarator:d gcc_asm_expr? gcc_attribute*                      -> d,

    dir_declarator  = dir_declarator:d pmember_decl(d)
                    | dir_declarator:d pcall_decl(d)
                    | "(" gcc_attribute* declarator:d ")"                                -> {d.type('func'); d}
                    | "Id":s                                                             -> __.Declarator().name(s.value())
                    | "Typename":t                                                       -> __.Declarator().name(t.value()),


    abs_declarator  = pointer_list:p dir_abs_declarator:d gcc_asm_expr? gcc_attribute*   -> { d.pointer(p); d }
                    | pointer_list:p                                                     -> { d = __.AbsDeclarator(); d.pointer(p); d }
                    | dir_abs_declarator:d gcc_asm_expr? gcc_attribute*                  -> d,

    dir_abs_declarator  = dir_abs_declarator:d "[" const_expr?:e "]"            -> {d.type('member'); d.append(e); d}
                        | "[" const_expr?:e"]"                                  -> { d = __.AbsDeclarator().type('member'); d.append(e); d}
                        | dir_abs_declarator:d "(" param_type_lst?:p ")"        -> { d.type('call'); d.appendAll(p); d}
                        | "(" param_type_lst?:p ")"                             -> { d = __.AbsDeclarator().type('call'); d.appendAll(p); d}
                        | "(" gcc_attribute* abs_declarator:d ")"               -> d,

    pmember_decl :p = "[" gcc_array_type_modifier* const_expr:e "]" -> { p.type('member'); p.append(e); p }
                    | "[" gcc_array_type_modifier* empty "]"        -> { p.type('member'); p },

    pcall_decl :p   = "(" (param_type_lst:pl                        -> { p.type('call'); p.appendAll(pl); p }
                            | ident_list:ll                         -> { p.type('call'); p.appendAll(ll); p }
                            | empty ) ")"                           -> { p.type('call'); p },

    // opointer         = "*"+:pn ( "const" | "volatile" )?:pt pointer? gcc_attribute*         -> {pointer_level:pn.length, pointer_type:pt === undefined? pt : pt.value()},
    
    pointer         = "*" type_qualifier*:t                         -> { p = __.Pointer(); p.appendAll(t); p },

    pointer_list    = pointer+:p                                    -> { pl = __.PointerList(); pl.appendAll(p); pl },


    ident_list      = listOf(#id, ','),

    param_type_lst  = listOf(#param_decl, ","):p "," var_args:a     -> {p.push(a);p}
                    | listOf(#param_decl, ","):p                    -> p,

    var_args        = "..."                                         -> __.VarArgs(),

    param_decl      = decl_specs:ds declarator:dl                   -> __.ParamDeclaration(ds, dl)
                    | decl_specs:ds abs_declarator:ad               -> __.ParamDeclaration(ds, ad)
                    | decl_specs:ds                                 -> __.ParamDeclaration(ds, undefined),

    initializer     = "{" listOf(#initializer, ","):p ","? "}"      -> __.GroupInitializer((p.length > 1? __.SequenceExpr(p) : p[0]))
                    | "{" listOf(#designator, ","):p ","? "}"       -> __.GroupInitializer(__.SequenceExpr(p).type("designator"))
                    | assign_expr,
    
    designator      = "." assign_expr,

    // GCC Statements
    //
    gcc_decl_spec   = gcc_attribute
                    | gcc_ext_spec,

    // gcc_attribute   = "__attribute__" "(" "(" attribute_param ("," attribute_param)* ")" ")",
    gcc_attribute   = "__attribute__" "(" "(" (~(")" ")") anything)* ")" ")"+       -> __.Attribute(),

    attribute_param = gcc_any_word?
                    | gcc_any_word "(" (assign_expr ("," assign_expr)* )? ")",

    gcc_any_word    = ("Id"|"Typename")
                    | store_cl_spec
                    | type_spec
                    | type_qualifier
                    | func_spec,

    gcc_ext_spec    = "__extension__":s                                 -> __.TypeSpec().type(s.value()),

    func_spec       = "inline":f                                        -> __.FuncSpec().type(f.value())
                    | msvs_func_spec:f                                  -> __.FuncSpec().type(f.value()),

    msvs_func_spec  = "__inline"
                    | "__forceinline"
                    | "__inline__",

    gcc_array_type_modifier = type_qualifier
                            | gcc_attribute,

    gcc_asm_stmt    = gcc_asm_expr ";"                                  -> __.Asm(),

    // gcc_asm_expr    = ("__asm__" | "__asm") type_qualifier? "(" expr 
    //                     (":" ( gcc_asm_operand ("," gcc_asm_operand)* )? 
    //                         (":" (gcc_asm_operand ("," gcc_asm_operand)*)? 
    //                             (":" string ("," string)*)?)?)? ")",

    // gcc_asm_operand = ("[" ("Id"|"Typename") "]")? string "(" expr ")",


    gcc_asm_expr    = ("__asm__" | "__asm") type_qualifier? "(" (~")" anything)* ")"+,


    // C Statements
    //

    stmt            = jcallback_stmt
                    | labeled_stmt
                    | compound_stmt
                    | selection_stmt
                    | iteration_stmt
                    | jump_stmt
                    | expr_stmt
                    | gcc_asm_stmt,

    jcallback_stmt  = "Typename":jc ?(jcallbacks.has(jc.value())) "(" listOf(#assign_expr, ","):as ")" ";"  -> __.JCallbackStmt(jc.value(), as),

    expr_stmt       = expr?:e ";"                                           -> __.ExprStmt(e),

    labeled_stmt    = "Id":l ":" stmt:s                                     -> __.LabeledStmt(l.value(), s)
                    | "case" const_expr:e ":" stmt:s                        -> __.CaseStmt(e, s)
                    | "default" ":" stmt:s                                  -> __.DefaultStmt(s),

    compound_stmt   = "{" (declaration|stmt)*:i "}"                         -> __.CompoundStmt(i),

    selection_stmt  = "if" "(" expr:e ")" stmt:s ( "else" stmt:f            -> __.IfStmt(e, s, f)
                                                    | empty                 -> __.IfStmt(e, s)
                                                 )
                    | "switch" "(" expr:e ")" stmt:s                        -> __.SwitchStmt(e, s),

    iteration_stmt  = "while" "(" expr:e ")" stmt:s                             -> __.WhileStmt(e, s)
                    | "do" stmt:s "while" "(" expr:e ")" ";"                    -> __.DoWhileStmt(e, s)
                    | "for" "(" (declaration | expr_stmt):se expr_stmt:ee expr?:ie ")" stmt:s   -> __.ForStmt(se, ee, ie, s),

    jump_stmt       = "goto" "Id":l ";"                         -> __.GotoStmt().label(l.value())
                    | "continue" ";"                            -> __.ContinueStmt()
                    | "break" ";"                               -> __.BreakStmt()
                    | "return" expr?:e ";"                      -> __.ReturnStmt(e),

    external_decl   = function_def
                    | declaration,

    function_def    = decl_specs:ds declarator:dc 
                        { calls = new Set();} 
                        compound_stmt:s
                        { callGraph.set(dc.name(), calls); }    -> {
                                                                            var params = [];
                                                                            for (var i = 2; i < dc.length; i++) {
                                                                                var param = dc[i];
                                                                                params.push({
                                                                                    type: param[2][2].type(),
                                                                                    pointer: param[3].pointer()
                                                                                });
                                                                            }
                                                                            functions.set(dc.name(), params);
                                                                            __.FuncDefinition(ds, dc, s)
                                                                           },

    translation_u   = external_decl+:s                            -> __.Program(s),

    topLevel        = translation_u:u spaces end    -> u
}


// Configure position information callback
CParser.position_info = function(input, from, to) {

    function position(pos) {
        var line  = 1,
        column = undefined;

        // scroll backwards to next linebreak
        for(var i=pos; i>=0; i--) {

            if(input[i] === "\n") {
                // only for the first time search column
                if(typeof column == 'undefined')
                    column = pos - i;

                line++
            }
        }

        if(line === 1)
            column = pos;

        return {
            line: line,
            column: column
        }
    }

    return {
        source: input.slice(from, to),
        start: position(from),
        end: position(to)
    }
};

CParser.spec = {

    // for C95.. we might have to add more keywords for C99
    keywords:   ["__attribute__", "__asm", "__asm__", "auto", "__based", "_Bool", "break", "case", "__cdecl", "char", "const", "continue", "default",
                 "do", "double", "else", "enum", "__extension__", "extern", "__fascall", "float", "for", "__forceinline", "goto",
                 "if", "__inline__", "__inline", "inline", "int", "long", "restrict", "__restrict", "__restrict__", "register", "return", "short", "signed",
                 "sizeof", "static", "__stdcall", "struct", "switch", "typedef", "union",
                 "unsigned", "void", "volatile", "while"],

    addKeywords:    function(l) { if (Array.isArray(l)) { this.keywords = this.keywords.concat(l); } },

    isKeyword:  function(k) { return this.keywords.indexOf(k) != -1; },

    typenames:   new Set(["__builtin_va_list"]),

    addTypename:   function(l) { 
        this.typenames.add(l);
    },

    isTypename:  function(k) { 
        return this.typenames.has(k);
    }

};

CParser.setActivity = function(input) {
  calls = new Set();
  currentFunction = input[2].name();
  // Loop over each param in the declaration
  for (var i = 2; i < input[2].length; i++) {
    var param = input[2][i];
    if(param[2][2][1].type == 'jcallback') {
      jcallbacks.add(param[3][1].name);
    }
  }
}

CParser.clearActivity = function() {
  callGraph.set(currentFunction, calls);
  currentFunction = "";
  jcallbacks = new Set();
}

CParser.setSyncActivity = function(input) {
    calls = new Set();
    currentFunction = input[3].name();
}
// CParser.printCallGraph = function() {
//     console.log(callGraph);
//     callGraph.forEach(function(calls, func) {
//         calls.forEach(function(call) {
//             console.log(func + ' -> ' + call);
//         });
//     });
// };

CParser.parse = function(input) {
    return CParser.matchAll(input, 'topLevel');
};

CParser.callbacks = callbacks;
CParser.callGraph = callGraph;
module.exports = CParser
