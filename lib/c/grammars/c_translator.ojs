/**
 * Copyright (c) 2015 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENSE file at the root of the project for the full license.
 *
 * This translator borrows quite liberally from the awesome ES5Translator built by
 * Jonathan Brachth√§user (http://b-studios.de).
 */

// Dependencies
var JsonMLWalker = require('../../../deps/jsonml/grammars/jsonml_walker.ojs'),
    join         = require('../../../utils.js').join,
    getNum       = require('../../../utils.js').getNum,
    escape       = require('../../../utils.js').escape_string;
var jasync_names = new Set();

ometa CTranslator <: JsonMLWalker {

    // Literals
    //
    Id              :n                                                                  -> n.value(),

    Number          :n  = ?n.is('kind', 'hex')                                          -> join('0x', n.value().toString(16))
                        | ?n.is('kind', 'oct')                                          -> join('0', n.value().toString(8))
                        | ?n.is('kind', 'char')                                         -> getNum(n.original(), 'char')
                        | ?n.is('kind', 'char_hex')                                     -> getNum(n.original(), 'hex')
                        | ?n.is('kind', 'char_oct')                                     -> getNum(n.original(), 'oct')
                        | ?n.is('kind', 'char_escape')                                  -> getNum(n.original(), 'escape')
                        | ?n.is('kind', 'double')                                       -> join(n.original().toString(), "L")
                        | ?n.is('value', parseFloat(n.original()))                      -> n.original()           // if something changed then don't
                        | empty                                                         -> n.value().toString(),  // use the original string representation

    String          :n                                                                  -> join('"', escape(n.value()), '"'),

    // Expressions
    //
    SequenceExpr    :n  = ?n.is('type', 'designator') walk*:es                          -> es.map(function(e) {return '.' + e}).join(', \n')
                        | walk*:es                                                      -> es.join(', '),

    AssignExpr      :n  = walk:lhs walk:rhs                                             -> join(lhs, ' ', n.operator(), ' ', rhs),

    CondExpr        :n  = walk:ce walk:t walk:f                                         -> join(ce, ' ? ', t, ' : ', f),

    BinaryExpr      :n  = walk:lhs walk:rhs                                             -> join(lhs, ' ', n.operator(), ' ', rhs),

    CastExpr        :n  = walk:lhs walk:rhs                                             -> join(lhs, rhs),

    UpdateExpr      :n = walk:e ( ?n.is('prefix')                                       -> join(n.operator(), e)
                                | empty                                                 -> join(e, n.operator())
                                ),

    UnaryExpr       :n = walk?:e                                                        -> {e !== undefined ? join(n.operator(), ' ', e): n.operator()},
    
    CallExpr        :n = walk:e walk*:args                                              -> join(e, '(', args.join(', '), ')'),

    MemberExpr      :n = ?n.is('access', 'name') walk:e                                 -> join(e, '.', n.name())
                       // | ?n.is('access', 'name') walk:p walk:e                          -> join(p, '.', n.name(), e)
                       | walk:e walk:ae                                                 -> join(e, '[', ae, ']'),

    PointerExpr     :n = ?n.is('access', 'pointer') walk:e                              -> join(e, '->',  n.name()),

    GroupExpr       :n = walk:e                                                         -> join('(', e, ')'),

    // Declarations
    //

    StorageClassSpec    :n = empty                                                      -> n.class(),

    FuncSpec    :n     = empty                                                          -> n.type(),

    TypeSpec    :n     = walk?:e                                                        -> {["enum", "struct", "union"].indexOf(n.type()) > -1 ? e : n.type(); },

    TypeQual    :n     = empty                                                          -> n.type(),

    DeclSpec    :n     = walk+:l                                                        -> l.join(' '),

    Declaration :n     = walk:ds walk*:l                                                -> join(ds, l.join(','), ';'),

    TypeName    :n     = walk:s walk?:ad                                                -> join("(", s, ad, ")"),

    InitDecl    :n     = walk:d walk?:i                                                 -> {i !== undefined ? join(d, ' = ', i) : d},

    AbsDeclarator   :n = ?n.is('type', 'member') walk*:e                                -> {join(this.print_ptr(n), '[', e.join(']['), ']')}
                       | ?n.is('type', 'call') walk*:e                                  -> {join(this.print_ptr(n), '(', e.join(', '), ')')}
                       | ?n.is('type', 'func') walk*:e                                  -> {join('(',this.print_ptr(n), ')', '(', e.join(', '), ')')}
                       | empty                                                          -> {
                                                                                            if (n.is('type', 'member'))
                                                                                                return join(this.print_ptr(n), n.name(), '[]');
                                                                                            else if (n.is('type', 'call')) {
                                                                                                return join(this.print_ptr(n), '()');
                                                                                            } else
                                                                                                return this.print_ptr(n);
                                                                                           },

    Declarator      :n = ?n.is('type', 'member') walk+:e                         -> {join(this.print_ptr(n), ' ', n.name(), '[', e.join(']['), ']')}
                       | ?n.is('type', 'call') walk+:e                           -> {join(this.print_ptr(n), ' ', n.name(), '(', e.join(', '), ')')}
                       | ?n.is('type', 'func') walk+:e                           -> {join('(',this.print_ptr(n), n.name(), ')', '(', e.join(', '), ')')}
                       | empty                                                        -> {
                                                                                            if (n.is('type', 'member'))
                                                                                                return join(this.print_ptr(n), ' ', n.name(), '[]');
                                                                                            else if (n.is('type', 'call')) {
                                                                                                if(n.name() == "main") {
                                                                                                    return join(this.print_ptr(n), ' ', "user_main", '()');
                                                                                                } else {
                                                                                                    return join(this.print_ptr(n), ' ', n.name(), '()');
                                                                                                }
                                                                                            } else {
                                                                                                return join(this.print_ptr(n), ' ', n.name());
                                                                                            }
                                                                                           },
    PCall         :n = walk?:pc                                                        -> "()",

    PMember       :n = walk?:pm                                                        -> "[]",

    Attribute         :n = empty                                                        -> "",

    Asm               :n = empty                                                        -> "",

    ParamDeclaration  :n = walk:ds walk:d                                               -> join(ds, ' ', d),

    VarArgs           :n = empty                                                        -> '...',

    GroupInitializer  :n = walk+:p                                                      -> join('{', p.join(','), '}'),

    EnumDeclaration   :n  = walk*:d                                                     -> {d.length > 0? join('enum ', n.name(), ' {', d.join(','), '} ') : join('enum ', n.name())},

    Enumerator      :n = walk?:d                                                        -> {d !== undefined? join(n.name(), ' = ', d) : n.name()},

    StrucSpec       :n = walk*:s                                                        -> {s.length > 0? join('struct ', n.name(), ' {', s.join('\n'), '}') : join('struct ', n.name())},

    UnionSpec       :n = walk*:s                                                        -> {s.length > 0? join('union ', n.name(), ' {', s.join('\n'), '}') : join('union ', n.name())},

    StrucDecl       :n = walk:s walk*:l                                                 -> join(s, l.join(','), ';'),

    SpecQList       :n = walk+:l                                                        -> l.join(' '),

    SDeclarator     :n = walkType(#Declarator)?:d walk?:e                               -> { if (d === undefined)
                                                                                                return join(": ", e);
                                                                                             else if (e === undefined)
                                                                                                return d;
                                                                                             else
                                                                                                return join(d, " : ", e);
                                                                                           },

    Pointer         :n = walk*:t                                                        -> join('*', ' ', t.join(' ')),                                                                                   

    PointerList     :n = walk+:p                                                        -> p.join(' '),                                                                                   

    // Statements
    //

    ExprStmt        :n = walk*:s                                                        -> join(s.join('\n'), ";"),

    LabeledStmt     :n = walk:s                                                         -> join(n.label(), ': ', s),

    CaseStmt        :n = walk:ex walk:st                                                -> join('case ', ex, ':', st),

    DefaultStmt     :n = walk:s                                                         -> join('default:', s),

    CompoundStmt    :n = walk*:d walk*:s                                                -> join('{\n', this.indent(this.join_sc(d)), this.indent(this.join_sc(s)), '}\n'),

    IfStmt          :n = walk:c walk:t ( walk:f                                         -> join('if(', c, ') ', t, ' else ', f, ';')
                                               | (undefined | empty)                    -> join('if(', c, ') ', t, ';')
                                               ),

    SwitchStmt      :n = walk:se walk:st                                                -> join('switch', '(', se, ')', st),

    WhileStmt       :n = walk:ce walk:s                                                 -> join('while(', ce, ') ', s),

    DoWhileStmt     :n = walk:s walk:ce                                                 -> join('do ', ce, ' while(', s, ')', ';'),

    ForStmt         :n = walk:ie walk:ce walk:ue walk:s                                 -> join('for(', ie, '; ', ce, '; ', ue, ') ', s, ';'),

    GotoStmt        :n = empty                                                          -> join('goto ', n.label(), ';'),

    ContinueStmt    :n = empty                                                          -> 'continue;',

    BreakStmt       :n = empty                                                          -> 'break;',

    ReturnStmt      :n = walk:e ( ?(e !== undefined)                                    -> join('return ', e, ';')
                                | empty                                                 -> 'return;'
                                ),

    // Function or Program Statements
    //

    FuncDefinition  :n = walk?:ds walk:de walk:st                                       -> {ds === undefined? join(de, st) : join(ds, de, st)},

    Program         :n = walk*:cs                                                       -> cs.join('\n')

}

CTranslator.print_ptr = function(n) {
    return CTranslator.match(n.pointer(), 'walk');
}


// join with semicolons and linebreaks
CTranslator.join_sc = function(cs) {

    var output = [];

    for(var i = 0; i < cs.length; i++)
        output.push(cs[i]);
    return output.join('\n');
};

CTranslator.indent = function(source, opts) {

    opts = opts || {};

    function defaults(key, value) { if(typeof opts[key] == 'undefined') opts[key] = value; }

    defaults('width',      this.tab_width);
    defaults('first_line', true);

    var space = Array(opts.width+1).join(' ');
    return (opts.first_line ? space : '') + source.split('\n').join('\n' + space);
};

CTranslator.tab_width = 4;
CTranslator.force_rules = true;
CTranslator.translate = function(input, data) {
    if(data !== undefined) {
        jasync_names = data.jasync_names;
    }
    return CTranslator.match(input, 'walk');
};

module.exports = CTranslator;
