---
layout: page
title: JData
subtitle: JData Documentation
---

<head>
	<style>
		.myNavbar{
		  margin-bottom: 20px;
		  border-radius: 10px;	
		}
		
		.myPanel{
		  display: flex;
		  flex-direction: column;
		  justify-content: space-between;
		  align-items: flex-start;
		  padding: 20px;
		  display: none;
		}

		.myNavbar a{
		  display: block;
		  margin-bottom: 10px;
		  text-decoration: none;
		  color: #444;
		}

		button.myAccordion {
		    background-color: #eee;
		    color: #444;
		    cursor: pointer;
		    padding: 18px;
		    width: 100%;
		    text-align: left;
		    border:none;
		    border-bottom: 2px #ddd solid;
		    outline: none;
		    transition: 0.4s;
		}

		button.myAccordion.active, button.myAccordion:hover {
		    background-color: #ddd;
		}

		.content > div{
		  background-color: #eee;
		  padding: 20px;
		  margin-bottom: 20px;
		  border-radius: 10px;
		}

		.content>div>div{
		  border-bottom: 2px #ddd solid;
		  margin-bottom: 40px;
		}

		pre {
		  background-color: white;
		  font-family: monospace;
		  font-size: 14px;
		  color: #444;
		  padding: 0.75em;
		  border-radius: .25em;
		  box-shadow: .1em .1em .5em rgba(0,0,0,.45);
		  line-height: 0;
		  counter-reset: line;
		}

		pre > span {
		  display: block;
		  line-height: 1.75rem;
		}    

		span:before {
		  counter-increment: line;
		  content: counter(line);
		  display: inline-block;
		  border-right: 1px solid #ddd;
		  padding: 0 .5em;
		  margin-right: .5em;
		  color: #888
		}

		#top-btn{
			position: fixed;
			width: 60px;
			height: 50px;
			bottom: 50px;
			right: 60px;
		}
	</style>
</head>

<body>
  <div class="myContainer">
    <div class="myNavbar" id="top">
      <button class="myAccordion datasource">JAMDatasource</button>
      <div class="myPanel">
        <a class="intro" href="#datastource">Introduction</a>
        <a class="logger" href="#logger">JAMLogger</a>
        <a class="logger-samples" href="#logger-samples">&nbsp;&nbsp;&nbsp;&nbsp;- Sample Logger Programs</a>
        <a class="broadcaster" href="#broadcaster">JAMBroadcaster</a>
        <a class="broadcaster-samples" href="#broadcaster-samples">&nbsp;&nbsp;&nbsp;&nbsp;- Sample Broadcaster Programs</a>
      </div>
      <button class="myAccordion datastream">JAMDatastream</button>
      <div class="myPanel">
		<a href="#datastream-intro" class="intro">Introduction</a>
		<a href="#datastream-apis">JAMDatastream APIs</a>
		<a href="#size">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.size()</a>
		<a href="#lastdata">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.lastData()</a>
		<a href="#lastvalue">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.lastValue()</a>
		<a href="#data">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.data()</a>
		<a href="#values">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.values()</a>
		<a href="#ndata">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.n_data()</a>
		<a href="#nvalues">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.n_values()</a>
		<a href="#dataafter">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.dataAfter()</a>
		<a href="#valuesafter">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.valuesAfter()</a>
		<a href="#databetween">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.dataBetween()</a>
		<a href="#valuesbetween">&nbsp;&nbsp;&nbsp;&nbsp;- JAMDatastream.valuesBetween()</a>
      </div>
      <button class="myAccordion flow">Flow</button>
      <div class="myPanel">
		<a href="#flow">Introduction</a>
		<a href="#5flow">5 Types of Flow</a>
		<a href="#iteratorflow">Iterator Flow</a>
		<a href="#outflow&inflow">OutFlow & InFlow</a>
		<a href="#in&out-samples">&nbsp;&nbsp;&nbsp;&nbsp;- Sample programs</a>
		<a href="#discretizedflow">Discretized Flow</a>
		<a href="#discretized-samples">&nbsp;&nbsp;&nbsp;&nbsp;- Sample programs</a>

		<a href="#flow-methods">Flow Methods</a>

		<a href="#limit">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.limit()</a>
		<a href="#skip">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.skip()</a>
		<a href="#skipuntil">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.skipUntil()</a>
		<a href="#skipwhile">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.skipWhile()</a>
		<a href="#select">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.select()</a>
		<a href="#selectexpand">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.selectExpand()</a>
		<a href="#selectflatten">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.selectFlatten()</a>
		<a href="#takeuntil">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.takeUntil()</a>
		<a href="#takewhile">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.takeWhile()</a>
		<a href="#where">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.where()</a>
		<a href="#orderby">- Flow.orderBy()</a>
		<a href="#partitionby">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.partitionBy()</a>
		<a href="#merge">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.merge()</a>
		<a href="#range">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.range()</a>
		<a href="#discretize">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.discretize()</a>

		<a href="#flow-actions">Flow Actions</a>

		<a href="#count">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.count()</a>
		<a href="#sum">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.sum()</a>
		<a href="#min">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.min()</a>
		<a href="#max">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.max()</a>
		<a href="#average">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.average()</a>
		<a href="#groupby">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.groupBy()</a>
		<a href="#collect">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.collect()</a>
		<a href="#join">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.join()</a>
		<a href="#foreach">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.forEach()</a>
		<a href="#findfirst">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.findFirst()</a>
		<a href="#findLast">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.findLast()</a>
		<a href="#anymatch">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.anyMatch()</a>
		<a href="#allmatch">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.allMatch()</a>
		<a href="#nonematch">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.noneMatch()</a>
		<a href="#reduce">&nbsp;&nbsp;&nbsp;&nbsp;- Flow.reduce()</a>

      </div>
    </div>
    <div class="content">
    
	    <div id="datastource">
	    	<div>
		        <h2>JAMDatasource</h2>  
				<p>JAMDatasource is the core of data transmission among different machines in a JAM system. Its value can be updated to trigger certain actions on its subscriber applications both locally and on other machines, through another data type called JAMDatastream.</p>
		        <p>JAMDatasource has two subtypes: JAMLogger and JAMBroadcaster, with the former being a bottom-up data media, and the latter a top-down channel.</p>
	    	</div>

			<div id="logger">
				<div>
			        <h3>JAMLogger</h3>
			        <p>A JAMLogger keeps track of the changes of a value. Instances of JAMLogger should be declared in J-node applications, which is then able to subscribe user-defined functions to the logger when its value gets updated. The value tracked can be changed by a C-node, if the J-node is at device level, or by a device-level J-node, if the J-node is at fog or cloud level.</p>
				</div>

		        <div>
			        <p><b>How to declare a logger variable?</b></p>
			        <p>A logger has to be declared in a jdata{...} section.</p>
			        <pre>
					<span>jdata{</span>
					<span>  &lt;type&gt; &lt;name&gt; as logger;</span>
					<span>}</span>
			        </pre>
					<p><code>&lt;type&gt;</code>: the type of the value that the logger keeps track of. Possible values: int, double, float, char*, and user-defined structures.</p>
					<p><code>&lt;name&gt;</code>: the name of this logger.</p>

			      	<p><b>Example:</b> declaring a logger to keep track of an integer value:</p>
					<pre>
					<span>jdata {</span>
					<span>  int num as logger;</span>
					<span>}</span>
					</pre>
					<p>A <b>structural logger</b> is declared using the syntax of C Prgoramming Language.</p>
					<p><b>Example:</b> declaring another logger to keep track of an user-defined type - struct weather:</p>
					<pre>
					<span>jdata {</span>
					<span>  struct weather{</span>
					<span>    float temperature;</span>
					<span>		float humidity;</span>
					<span>		float wind;</span>
					<span>		char* air_quality;</span>
					<span>		char* UV;</span>
					<span>	} MTLWeather as logger;</span>
					<span>}</span>
					</pre>
				</div>

				<div>
			      	<b>How to bind actions to a logger on value changes?</b>
			      	<p>The <b>subscribe()</b> method pushes a callback function to the logger that it is called upon, such that all the applications that listens to this logger will call that function when the logger records a new value change.</p>
					<pre>
					<span>jdata {</span>
					<span>	int aNumber as logger;</span>
					<span>}</span>
					<span></span>
					<span>aNumber.subscribe(function(key, entry, datastream){</span>
					<span>	console.log("New data:",entry);</span>
					<span>});</span>
					</pre>
			      	<b>Syntax</b>  
					<pre>
					<span>JAMLogger.subscribe(function callback(key, entry, datastream){</span>
					<span>	// ...</span>
					<span>})</span>
					</pre>
					<b>Return value</b>  
					<p>None</p> 

					<b>Parameters</b>  
					<p>callback</p>
					<p>&nbsp;&nbsp;&nbsp;&nbsp;the function that is called by all listener applications of the logger that <b>subscribe()</b> is called upon.</p>  
					<p>&nbsp;&nbsp;&nbsp;&nbsp;key</p>  
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the identifier of the logger that <b>subscribe()</b> is called upon.</p>
					<p>&nbsp;&nbsp;&nbsp;&nbsp;entry</p>  
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the new data whose arrival triggers this callback function.</p>
					<p>&nbsp;&nbsp;&nbsp;&nbsp;datastream</p>  
						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the identifier of the listener application of the logger.</p> 
				</div> 
			</div>

			<div id="logger-samples">
				<h3>Example programs for your inspiration!</h3>
				
				<button class="myAccordion">Add callback functions to a logger by deploying datastream's methods</button>
				<div class="myPanel">
					<p>J-node</p> 
					<pre>
					<span>jdata{</span>
					<span>	int candidate1 as logger;</span>
					<span>}</span>
					<span></span>
					<span>var notify = function(key, entry, device){</span>
					<span>	console.log("key\n"+key);</span>
					<span>	var size = device.size();</span>
					<span>	console.log("Received "+size+" votes");</span>
					<span>	var lastData = device.lastData();</span>
					<span>	var timestamp = lastData.timestamp;</span>
					<span>	var lastValue = device.lastValue();</span>
					<span></span>
					<span>	console.log("Vote from "+lastValue+" at "+timestamp);</span>
					<span></span>
					<span>	var data = device.data();</span>
					<span>	var values = device.values();</span>
					<span></span>
					<span>	if(device.size()>=10){</span>
					<span>		var last10Data = device.n_data(10);</span>
					<span>		console.log("Last 10 votes with time_stamp:",last10Data);</span>
					<span>	}</span>
					<span></span>
					<span>	if(device.size()>=10){</span>
					<span>		var last10Values = device.n_values(10);</span>
					<span>		console.log("Last 10 votes are from", last10Values);</span>
					<span>	}</span>
					<span></span>
					<span></span>
					<span>	if(device.size()>20){</span>
					<span>		// get the 21th value received</span>
					<span>		var aValue = device.get_value_at(20);</span>
					<span>		console.log("The 20th vote is from",aValue);</span>
					<span>	}</span>
					<span></span>
					<span>	if(device.size()>20){</span>
					<span>		// get the 10 values starting from the 6th one received</span>
					<span>		var someValue = device.get_range_values(5, 10);</span>
					<span>		console.log("The 5th to the 15th votes are from",someValue)</span>
					<span>	}</span>
					<span></span>
					<span>	// year, month-1, date, hour, minute, secod</span>
					<span>	var today = new Date(2017, 7, 7, 0, 0, 0);</span>
					<span></span>
					<span>	var dataToday = device.dataAfter(today);</span>
					<span>	var valuesToday = device.valuesAfter(today);</span>
					<span>	console.log("Received "+valuesToday.length+" data today");</span>
					<span>	</span>
					<span>	var yesterday = new Date(2017, 7, 6, 0, 0, 0);</span>
					<span></span>
					<span>	var dataYesterday = device.dataBetween(today, yesterday);</span>
					<span>	var valueYesterday = device.valuesBetween(today, yesterday);</span>
					<span>	console.log("Received "+valueYesterday.length+" data yesterday");</span>
					<span>}</span>
					<span></span>
					<span>candidate1.subscribe(notify);</span>
					</pre>

					<p>C-node</p>
					<pre>
					<span>#include &lt;unistd.h&gt;</unistd.h>
					<span></span>
					<span>int main() {</span>
					<span>	for (int i = 0;; i++) {</span>
					<span>		candidate1 = i;</span>
					<span>		sleep(1);</span>
					<span>	}</span>
					<span>}</span>
					</pre>
				</div>

				<button class="myAccordion">Work with structural loggers</button>
				<div class="myPanel">
					<p>J-node</p>
					<pre>
					<span>jdata{</span>
					<span>	struct weather{</span>
					<span>		int temperature;</span>
					<span>		float humidity;</span>
					<span>		float wind;</span>
					<span>		char* airQuality;</span>
					<span>		char* UV;</span>
					<span>	} MTLWeather as logger;</span>
					<span>}</span>
					<span></span>
					<span>var notify = function(key, entry, device){</span>
					<span>	var size = device.size();</span>
					<span>	console.log("Logging the "+size+"-th data "+entry+" into logger "+" key");</span>
					<span></span>
					<span>	var lastData = device.lastData();</span>
					<span>	console.log("Last data received",lastData);</span>
					<span></span>
					<span>	var lastValue = device.lastValue();</span>
					<span>	console.log("Last value received",lastValue);</span>
					<span></span>
					<span>	var data = device.data();</span>
					<span></span>
					<span>	var values = device.values();</span>
					<span></span>
					<span>	if(device.size()>=10){</span>
					<span>		var last10Data = device.n_data(10);</span>
					<span>		console.log("Last 10 data received",last10Data);</span>
					<span>	}</span>
					<span></span>
					<span>	if(device.size()>=10){</span>
					<span>		var last10Values = device.n_values(10);</span>
					<span>		console.log("Last 10 values received",last10Values);</span>
					<span>	}</span>
					<span></span>
					<span></span>
					<span>	if(device.size()>20){</span>
					<span>		// get the 21th value received</span>
					<span>		var aValue = device.get_value_at(20);</span>
					<span>	}</span>
					<span></span>
					<span>	if(device.size()>20){</span>
					<span>		// get the 10 values starting from the 6th one received</span>
					<span>		var someValue = device.get_range_values(5, 10);</span>
					<span>	}</span>
					<span></span>
					<span>	// year, month-1, date, hour, minute, secod</span>
					<span>	var today = new Date(2017, 7, 14, 0, 0, 0);</span>
					<span></span>
					<span>	var dataToday = device.dataAfter(today);</span>
					<span>	var valuesToday = device.valuesAfter(today);</span>
					<span>	console.log("Received "+valuesToday.length+" data today");</span>
					<span>	</span>
					<span>	var yesterday = new Date(2017, 7, 13, 0, 0, 0);</span>
					<span></span>
					<span>	var dataYesterday = device.dataBetween(today, yesterday);</span>
					<span>	var valueYesterday = device.valuesBetween(today, yesterday);</span>
					<span>	console.log("Received "+valueYesterday.length+" data yesterday");</span>
					<span>}</span>
					<span></span>
					<span>MTLWeather.subscribe(notify);</span>
					</pre>

					<p>C-node</p>
					<pre>
					<span>#include &lt;unistd.h&gt;</span>
					<span>#include &lt;stdlib.h&gt;</span>
					<span></span>
					<span>int main() {</span>
					<span>	int temp;</span>
					<span>	float hum, wind;</span>
					<span></span>
					<span>	for (int i = 1;; i++) {</span>
					<span></span>
					<span>		temp  = rand()%15+15;</span>
					<span>		hum  = (rand()%100)/100;</span>
					<span>		wind = rand()%25+(rand()%10)/10;</span>
					<span></span>
					<span>		MTLWeather = {</span>
					<span>			.temperature: temp, </span>
					<span>			.humidity: hum,</span>
					<span>			.wind: wind,</span>
					<span>			.airQuality: "good",</span>
					<span>			.UV: "strong"</span>
					<span>		};</span>
					<span></span>
					<span>		sleep(1);</span>
					<span>	}</span>
					<span>}</span>
					</pre>
				</div>
			</div>

			<div id="broadcaster">
				<div>
					<h3>JAMBroadcaster</h3>
					<p>A JAMBroadcaster is responsible for broadcasting data in a top-down fashion, i,e. from cloud to fog or device, or from fog to device. Unlike JAMLogger, a broadcaster actively sends data instead of waiting for other applications to update its value.</p>
				</div>
		  
		  		<div>
					<p><b>How to declare a broadcaster variable?</b></p>
					<p>A broadcaster has to be declared in a jdata{...} section.</p>
					<pre>
					<span>jdata{</span>
					<span>	&lt;type&gt; &lt;name&gt; as broadcaster;</span>
					<span>}</span>
					</pre>
					<p><code>&lt;type&gt;</code>: the type of the value that the logger keeps track of. Possible values: int, double, float, char*, and user-defined structures.</p>
					<p><code>&lt;name&gt;</code>: the name of this broadcaster.</p>

				    <p><b>Example:</b> declaring a broadcaster to broadcast integer values:</p>
				    <pre>
					<span>jdata {</span>
					<span>	int num as broadcaster;</span>
					<span>}</span>
				    </pre>

			    	<p>A <b>structural broadcaster</b> is declared using the syntax of C Prgoramming Language.</p>
			    	<p><b>Example:</b> declaring another broadcaster to broadcast time - struct myTime:</p>
				    <pre>
					<span>jdata {</span>
					<span>  struct myTime{</span>
					<span>    int year;</span>
					<span>    int month;</span>
					<span>    int date;</span>
					<span>    int hour;</span>
					<span>    int minute;</span>
					<span>    int second;</span>
					<span>    char* display;</span>
					<span>  }MTLTime as broadcaster;</span>
					<span>}</span>
				    </pre>
				</div>
		    </div>

		    <div id="broadcaster-samples">
		    	<h3>Example programs for your inspiration!</h3>
		    	<button class="myAccordion">Build a broadcaster to send messages to all its listener C-nodes</button>
		    	<div class="myPanel">
			    	<p>J-node</p>
			    	<pre>
		    		<span>jdata {</span>
					<span>    char* curTime as broadcaster;</span>
					<span>}</span>
					<span></span>
					<span>setInterval(function(){</span>
					<span>	var d = new Date();</span>
					<span>	var now = String(Number(d.getYear()+1900)+"-"+Number(</span>
					<span>d.getMonth()+1)+"-"+d.getDate()+" "+</span>
					<span>d.getHours()+":"+d.getMinutes()+":"+d.getSeconds());</span>
					<span>d.getMonth()+1)+"-"+d.getDate()+"></span>
					<span>	curTime.broadcast(now);</span>
					<span>}, 1000);</span>
			    	</pre>

			    	<p>C-node</p>
			    	<pre>
		    		<span>#include &lt;stdio.h&gt;</span>
					<span>#include &lt;unistd.h&gt;</span>
					<span></span>
					<span>int main(int argc, char *argv[]) {</span>
					<span>	while (1) {</span>
					<span>		sleep(1);</span>
					<span>		printf("Current time\n%s\n", curTime);</span>
					<span>	}</span>
					<span>}</span>
			    	</pre>
			    </div>

			    <button class="myAccordion">Work with structural broadcasters</button>
			    <div class="myPanel">
			    	<p>J-node</p>
			    	<pre>
			    	<span>jdata {  </span>
					<span>    struct myTime{</span>
					<span>        int year;</span>
					<span>        int month;</span>
					<span>        int date;</span>
					<span>        int hour;</span>
					<span>        int minute;</span>
					<span>        int second;</span>
					<span>        char* display;</span>
					<span>    }MTLTime as broadcaster;</span>
					<span>}</span>

					<span>setInterval(function(){</span>
					<span>   var d       = new Date(),</span>
					<span>       year    = Number(d.getYear()+1900),</span>
					<span>       month   = Number(d.getMonth()+1),</span>
					<span>       date    = d.getDate(),</span>
					<span>       hour    = d.getHours(),</span>
					<span>       minute  = d.getMinutes(),</span>
					<span>       second  = d.getSeconds(),</span>
					<span>       display = String(year+"-"+month+"-"+date+" "+</span>
					<span>					hour+":"+minute+":"+second);</span>
					<span></span>
					<span>   MTLTime.broadcast({</span>
					<span>       year: year,</span>
					<span>       month: month,</span>
					<span>       date: date,</span>
					<span>       hour: hour,</span>
					<span>       minute: minute,</span>
					<span>       second: second,</span>
					<span>       display: display</span>
					<span>   });</span>
					<span>, 1000);</span>
			    	</pre>

			    	<p>C-node</p>
			    	<pre>
			    	<span>#include &lt;stdio.h&gt;</span>
					<span>#include &lt;unistd.h&gt;</span>
					<span></span>
					<span>int main(int argc, char *argv[]) {</span>
					<span>	struct myTime localstruct;</span>
					<span></span>
					<span>	while (1) {</span>
					<span>		sleep(1);</span>
					<span>		localstruct = MTLTime;	</span>
					<span>		printf("Current Time: %s\n", localstruct.display);</span>
					<span>	}</span>
					<span>}</span>
			    	</pre>
			    </div>
		    </div>
		</div>

	    <div id="datastream">
	    	<div>
		    	<h2>JAMDatastream</h2>
				<p>To run a J-node, we have to supply an app name with <code>--app=APP_NAME</code>. This app name is later used to referred to this application in other programs, such that they can access datasources declared in it. Whenever a program subscribes to a logger in another program, or receives data from a broadcaster on a higher level machine, a datastream is created and bridges data between these two ends.</p>

				<p>Users of JAMScript do not initialize datastreams as they are internally created. We provide rich APIs for you to manipulate information about and data stored in datastreams.</p>  
			<div>

			<div id="datastream-apis"></div>

			<div id="size">
				<h3>JAMDatastream.size()</h3>
				<p>The <b>size()</b> method returns the number of records the logger has tracked.</p>
				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	var size = datastream.size();</span>
				<span>	console.log("aNumber has recorded "+size+" value changes");</span>
				<span>	// stdout: aNumber has recorded 10 value changes</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.size();</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;The number of records the callee logger has tracked.</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None</p>
			</div>

			<div id="lastdata">
				<h3>JAMDatastream.lastData()</h3>
				<p>The <b>lastData()</b> method returns the latest value along with its timestamp.</p>
				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	var data = datastream.lastData();</span>
				<span>	console.log("Latest value is",lastData.value);</span>
				<span>	console.log("Updated at",lastData.timestamp);</span>
				<span></span>
				<span>	// stdout:</span>
				<span>	// Newest value is 32</span>
				<span>	// Updated at 2017-02-23T23:08:51.141Z4</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b>  </p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.lastData()</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns the last data pair (value, timestamp) in the data stream or null if the data stream is empty. Value is of type Number and timestamp is of type Date.</p>
				<p><b>Parameters</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
			</div>

			<div id="lastvalue">
				<h3>JAMDatastream.lastValue()</h3>
				<p>The <b>lastValue()</b> method returns the latest value.</p>

				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	var value = datastream.lastValue();</span>
				<span>	console.log("Latest value is",value);</span>
				<span></span>
				<span>	// stdout:</span>
				<span>	// Newest value is 32</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b>  </p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.lastValue()</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns the last value in the data stream or null if the data stream is empty. Value is of type Number.</p>
				<p><b>Parameters</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
			</div>

			<div id="data">
				<h3>JAMDatastream.data()</h3>
				<p>The <b>data()</b> method returns all the values in the data stream along with their timestamps.</p>

				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	var allData = datastream.data();</span>
				<span>	console.log("Display the entire record");</span>
				<span>	console.log(allData);</span>
				<span></span>
				<span>	// stdout:</span>
				<span>	// Display the entire record</span>
				<span>	// [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.data()</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns all the (value, timestamp) that the callee logger has recorded, or null if the data stream is empty. Value is of type Number and timestamp is of type Date.</p>
				<p><b>Parameters</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
			</div>

			<div id="values">
				<h3>JAMDatastream.values()</h3>
				<p>The <b>values()</b> method returns all the values in the data stream along with their p>timestamps.</p>

				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	var allValues = datastream.values();</span>
				<span>	console.log("Display the entire record");</span>
				<span>	console.log(allValues);</span>
				<span></span>
				<span>	// stdout:</span>
				<span>	// Display the entire record</span>
				<span>	// [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.values()  </p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns all the (value, timestamp) that the callee logger has recorded, or null if the data stream is empty. Value is of type Number and timestamp is of type Date.</p>
				<p>b>Parameters</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
			</div>

			<div id="ndata">
				<h3>JAMDatastream.n_data(n)</h3>
				<p>The <b>n_data()</b> method returns the last n values in the data stream along with their p>timestamps.</p>

				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	if(datastrea.size()>=10)</span>
				<span>		var data = datastream.n_data(10);</span>
				<span>	console.log("Display the most recent 10 records");</span>
				<span>	console.log(data);</span>
				<span></span>
				<span>	// stdout:</span>
				<span>	// Display the most recent 10 records</span>
				<span>	// [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.n_data(n)</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns an array containing the last N data pairs (value, timestamp) in the data stream. The values are of type Number and the timestamps are of type Date.</p>
				<p><b>Parameter</b></p> 
				<p>&nbsp;&nbsp;&nbsp;&nbsp;n: a positive integer. If n is invalid, then an exception is thrown. If there are fewer than N data pairs in the data stream, then the length of the returned array is smaller than N.</p>
			</div>

			<div id="nvalues">
				<h3>JAMDatastream.n_values(n)</h3>
				<p>The <b>n_values()</b> method returns the last n values in the data stream.</p>

				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	if(datastrea.size()>=10)</span>
				<span>		var values = datastream.n_values(10);</span>
				<span>	console.log("Display the most recent 10 records");</span>
				<span>	console.log(values);</span>
				<span></span>
				<span>	// stdout:</span>
				<span>	// Display the most recent 10 records</span>
				<span>	// [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.n_values(n)</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns an array containing the last N values (of type Number) in the data stream. Parameter N is a positive integer. If N is invalid, then an exception is thrown. If there are fewer than N values in the data stream, then the length of the returned array is smaller than N.</p>
				<p><b>Parameters</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;n: an integer value</p>
			</div>

			<div id="dataafter">
				<h3>JAMDatastream.dataAfter()</h3>
				<p>The <b>dataAfter()</b> method returns the values along with their timestamps recorded after a p>specific timestamp in the data stream.</p>

				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	var today = new Date(2017, 6, 19, 0, 0, 0);</span>
				<span>	var dataToday = device.dataAfter(today);</span>
				<span></span>
				<span>	console.log("Received "+dataToday.length+" data today");</span>
				<span></span>
				<span>	// stdout:</span>
				<span>	// Received 3000 data today</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.dataAfter(n)</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns an array containing all data pairs (value, timestamp) in the data stream with a timestamp after timestamp (exclusive). Value is of type Number and timestamp is of type Date.</p>  
				<p><b>Parameters</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;timestamp: a Date object</p>
			</div>

			<div id="valuesafter">
				<h3>JAMDatastream.valuesAfter()</h3>
				<p>The <b>valuesAfter()</b> method returns the values recorded after a specific timestamp in the p>data stream.</p>

				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
					var today = new Date(2017, 6, 19, 0, 0, 0);
				<span>	var valuesToday = datastream.valuesAfter(today);</span>
				<span></span>
				<span>	console.log("Received "+valuesToday.length+" values today");</span>
				<span></span>
				<span>	// stdout:</span>
				<span>	// Received 3000 values today</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.valuesAfter(timestamp)</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns an array containing all values of type Number in the datastream recorded after timestamp.</p>
				<p><b>Parameters</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;timestamp: a Date object</p>
			</div>

			<div id="databetween">
				<h3>AMDatastream.dataBetween()</h3>
				<p>The <b>dataBetween()</b> method returns the values recorded during a specifc time period in p>the data stream along with their timestamps.</p>

				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	// year, month-1, date, hour, minute, secod</span>
				<span>	var yesterday = new Date(2017, 6, 19, 0, 0, 0);</span>
				<span>	var today = new Date(2017, 6, 20, 0, 0, 0);</span>
				<span></span>
				<span>	var dataYesterday = datastream.dataBetween(yesterday, today);</span>
				<span>	console.log("Received "+numData+" data yesterday");</span>
				<span>	// stdout</span>
				<span>	// Received 5000 data yesterday</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.dataBetween(fromTimestamp, toTimestamp)</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns an array containing all data pairs (value, timestamp) in the data stream with a timestamp between fromTimestamp and toTimestamp (both exclusive). For each data pair, the value is of type Number and the timestamp is of type Date.</p>  
				<p><b>Parameters</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;fromTimestamp: a Date object</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;toTimestamp: a Date object</p>
			</div>

			<div id="valuesbetween">
				<h3>JAMDatastream.valuesBetween()</h3>
				<p>The <b>valuesBetween()</b> method returns the values recorded during a specifc time period in p>the data stream.</p>

				<pre>  
				<span>jdata {</span>
				<span>	int aNumber as logger;</span>
				<span>}</span>
				<span></span>
				<span>aNumber.subscribe(function(key, entry, datastream){</span>
				<span>	// year, month-1, date, hour, minute, secod</span>
				<span>	var yesterday = new Date(2017, 6, 19, 0, 0, 0);</span>
				<span>	var today = new Date(2017, 6, 20, 0, 0, 0);</span>
				<span></span>
				<span>	var valuesYesterday = datastream.valuesBetween(yesterday, today);</span>
				<span>	var numData = valuesYesterday.length;</span>
				<span>	console.log("Received "+numData+" values yesterday");</span>
				<span></span>
				<span>	// stdout</span>
				<span>	// Received 5000 values yesterday</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;JAMDatastream.valuesBetween(fromTimestamp, toTimestamp)  </p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Returns an array containing all values of type Number in the datastream with a timestamp between fromTimestamp and toTimestamp (both exclusive).</p>
				<p><b>Parameters</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;fromTimestamp: a Date object</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;toTimestamp: a Date object</p>
			</div>
  		</div>

  		<div id="flow">
  			<div>	
	  			<h2>Flow</h2>
	  			<p>Flow is an abstract data type that enables efficient processing of large data sets. It enables data transmission cross applications.</p>
  			</div>

	  		<div id="5flow">
		  		<h3>5 Types of Flow</h3>
		  		<p>Flow has 5 subtypes: Flow, IteratorFlow, OutFlow, InFlow, DiscretizedFlow and ParallelFlow. They are grouped based on the type of operations that can be performed on them. All of them inherit Flow methods and Flow functions defined in Flow class, and have their own specialized functionalities.</p>  
	  		</div>

	  		<div id="flow">
	  			<h3>Flow - the generic type of flow</h3>
	  			<p>All other four types of flow inherit properties and functionalities from Flow class. It is crucial to the internal implementation of flow. However, users of JAMScript will never implicit create instances of this generic type.</p>
	  			<p>What's important for users to know about the Flow class is its rich APIs that apply to all other types of flow.</p>
	  			<p>So here we go. Let's start with <b>flow operations</b></p>
	  		</div>

	  		<div id="flow-operations">
	  			<h3>Flow Operations</h3>
	  			<p>Flow operations can either be methods/transformations (operations that yield other Flows) or actions (operations that yield a result).</p>
	  		</div>

	  		<div id="flow-operations">
				<h3>Flow methods</h3>
				<p>Each flow method is a data transformation that yields another flow. A flow maintains a call tree to the flow operation before it. A flow method is lazily computed as the data is continuously pipelined to the next level of flow and is only computed when a flow action is called upon it.</p>    
			</div>

			<!--FLOW METHODS-->

			<div id="limit">
				<h3>Flow.limit()</h3>
				<p>The <b>limit(Number)</b> method limits the number of results obtained after the previous operation.</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3,4,5,6,7]);</span>
				<span>var anotherFlow = firstFlow.limit(4);	// anotherFlow contains [1,2,3,4]</span>
				</pre>
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.limit(n)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;n: an integer indicating the number of data to pipe.</p>
				<p>Return value</p>  
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains the first n data from the root flow.</p> 
			</div>

			<div id="skip">
				<h3>Flow.skip()</h3>
				<p>The <b>skip()</b> method ignores the first given number of results found after a previous operation.</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3,4,5,6,7]);</span>
				<span>var anotherFlow = firstFlow.skip(4);	// anotherFlow contains [5,6,7]</span>
				</pre>
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.skip(n)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;n: an integer indicating the number of data to skip.</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all data excluding the first n data from the root flow.</p>
			</div>

			<div id="skipuntil">
				<h3>Flow.skipUntil()</h3>
				<p>The <b>skipUntil()</b> method ignores the results found after a previous operation until the condition in the function argument returns true. The function will receive each piped input and should return a boolean.</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3,4,5,6,7]);</span>
				<span>var anotherFlow = firstFlow.skipUntil(function(entry){
				<span>	entry.data % 3 == 0;</span>
				<span>});	// anotherFlow contains [3,4,5,6,7]</span>
				</pre>
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.skipUntil(aFunction)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: a function that takes as input each value in the flow and returns a boolean value.</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all data starting from the first data on which <code>aFunction</code> evaluates to be true.</p>
			</div>

			<div id="skipwhile">
				<h3>Flow.skipWhile()</h3>
				<p>The <b>skip()</b> method ignores the results found after a previous operation while the input function evaluates to be true.</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3,4,5,6,7]);</span>
				<span>var anotherFlow = firstFlow.skipWhile(function(entry){
				<span>	entry.data&lt;4;</span>
				<span>});	// anotherFlow contains [4,5,6,7]</span>
				</pre>
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.skipWhile(aFunction)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: a function that takes as input each data in the flow and returns a boolean value.</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all data excluding the first data on which <code>aFunction</code> returns true.</p>
			</div>

			<div id="takeuntil">
				<h3>Flow.takeUntil()</h3>
				<p>The <b>takeUntil()</b> method keeps taking results found after a previous operation until the input function evaluates to be true.</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3,4,5,6,7]);</span>
				<span>var anotherFlow = firstFlow.takeUntil(function(entry){
				<span>	entry.data&gt;4;</span>
				<span>});	// anotherFlow contains [5,6,7]</span>
				</pre>
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.takeUntil(aFunction)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: a function that takes as input each data in the flow and returns a boolean value.</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all data excluding those comes after the data on which <code>aFunction</code> returns true.</p>
			</div>

			<div id="takewhile">
				<h3>Flow.takeWhile()</h3>
				<p>The <b>takeWhile()</b> method keeps taking results found after a previous operation while the input function evaluates to be true.</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3,4,5,6,7]);</span>
				<span>var anotherFlow = firstFlow.takeWhile(function(entry){
				<span>	entry.data&lt;4;</span>
				<span>});	// anotherFlow contains [1,2,3]</span>
				</pre>
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.takeWhile(aFunction)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: a function that takes as input each data in the flow and returns a boolean value.</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all data excluding those comes after the data on which <code>aFunction</code> returns false.</p>
			</div>

			<div id="select">
				<h3>Flow.select()</h3>
				<p>The <b>Flow.select()</b> method is similar to map in mad-reduce operations. It applies a provided function on every entry in the calling flow.</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3,4,5,6,7]);</span>
				<span>var anotherFlow = firstFlow.select(entry => entry*2);	// anotherFlow contains </span>
				<span>[2,4,6,8,10,12,14]</span>
				</pre>
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.select(aFunction)  </p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: a function that is going to be applied on every entry in the calling flow.</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all data returned by applying the provided function on every entry in the calling flow.</p>
			</div>
			
			<div id="selectflatten">
				<h3>Flow.selectFlatten()</h3>
				<p>The <b>selectFlatten()</b> method flattens a flow of arrays.</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3],[4,5],[6,7,8,9]);</span>
				<span>var anotherFlow = firstFlow.selectFlatten();	// anotherFlow contains [1,2,3,4,5,6,7,8,9]</span>
				</pre>  
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.selectFlatten()  </p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all data in the calling flow in the flattened form.</p>
			</div>

			<div id="selectexpand">
				<h3> Flow.selectExpand()</h3>
				<p>The <b>selectExpand()</b> method flattens a flow of arrays and applies the provided function to each entry of the flattened flow. The colection generated by function must be supported by Flow.from(...).</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3],[4,5],[6,7,8,9]);</span>
				<span>var anotherFlow = firstFlow.selectExpand(data => data*2);	// anotherFlow contains <span></span>[2,4,6,8,10,12,14,16,18]</span>
				</pre>  
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.selectExpand(aFunction)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: a function that is going to be applied on each data in the flattened flow.</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all results returned by applying the provided function on every data in the calling flow in the flattened form.</p>
			</div>

			<div id="where">
				<h3>Flow.where()</h3> 
				<p>The <b>where()</b> method performs a filtering operation on the data to match a constraint.</p>  
				<pre>
				<span>var firstFlow = Flow.from([1,2,3,4,5,6,7]);</span>
				<span>var anotherFlow = firstFlow.where(entry => entry%2 == 0);	// anotherFlow contains [1, 4, 6]</span>
				</pre>  
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.where(aFunction)</p>
				<p>Parameter  </p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: a function that is going to be applied on each data in the flattened flow. It returns a boolean.</p>  
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all data whose <code>aFunction(data)</code> is true.</p>
			</div>
			
			<div id="orderby">
				<h3>Flow.orderBy()</h3>
				<p>The<b>orderBy()</b>method performs a sorting operation on the data based on a given function.</p>
				<pre>
				<span>var firstFlow = Flow.from([9,1,8,3,7,4,2,5,6]);</span>
				<span></span>
				<span>// anotherFlow contains [1,2,3,4,5,6,7,8,9]  </span>
				<span></span>
				<span>// anotherFlow contains [9,8,7,6,5,4,3,2,1]  </span>
				<span>var yetAnotherFlow = firstFlow.orederBy((data1, data2) => {</span>
				<span>	if(data1 < data2) return -1;</span>
				<span>	if(data1 > data2) return 1;</span>
				<span>	return 0;</span>
				<span>});		</span>
				</pre>  
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.orderBy(compareFunction)  </p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;compareFunction (optional): a function that defines an alternative sort order. The function takes two arguments, say data1 and data2. If a positive value is returned, then data1 is sorted before data2; if a negative value is returned, then data2 is sorted before data1; if 0 is returned, then data1 and data2 preserves their original order.</p>  
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains all data in the calling flow in the intended sorted order.</p>
			</div>
 
 			<div id="partitionby">
				<h3>Flow.partitionBy()</h3>
				<p>The <b>partitionBy()</b> method returns a new Flow containing several datasets grouped by a specified key. This is similar to groupBy() in Flow Actions</p> 
				<pre>
				<span>var firstFlow = Flow.from([</span>
				<span>	{	</span>
				<span>		type: "student",</span>
				<span>		year: "U2"</span>
				<span>		name: "Lilly"</span>
				<span>	},</span>
				<span>	{</span>
				<span>		type: "student",</span>
				<span>		year: "U0"</span>
				<span>	},</span>
				<span>	{</span>
				<span>		type: "professor",</span>
				<span>		name: "Tom"</span>
				<span>	},</span>
				<span>	{</span>
				<span>		type: "professor",</span>
				<span>	}</span>
				<span>]);</span>
				<span></span>
				<span>/* anotherFlow contains </span>
				<span>{</span>
				<span>	"student": [</span>
				<span>		{	</span>
				<span>			type: "student",</span>
				<span>			year: "U2"</span>
				<span>			name: "Lilly"</span>
				<span>		},</span>
				<span>		{</span>
				<span>			type: "student",</span>
				<span>			year: "U0"</span>
				<span>			name: "Jim"</span>
				<span>		}</span>
				<span>	],</span>
				<span>	"professor":[</span>
				<span>		{</span>
				<span>			name: "Tom"</span>
				<span>		},</span>
				<span>		{</span>
				<span>			type: "professor",</span>
				<span>			name: "Anne"</span>
				<span>	]</span>
				<span>}</span>
				<span>*/</span>
				<span>var anotherFlow = firstFlow.partitionBy("type");</span>
				</pre>  
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.partitionBy(key)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;key: a string indicating the key used to group data in the calling flow.</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow containing data in the calling flow partitioned into groups of array determined by the values of the intended key.</p>
			</div>

			<div id="merge">
				<h3>iteratorFlow.merge()</h3>
				<p>The <b>merge()</b> method is only available to an object of IteratorFlow and is used to merge a supported data structure. Merging creates an Iterator and adds it to the current Iterator or Iterators.</p>   
			</div>

			<div id="range">  
				<h3>Flow.range()</h3>
				<p>The <b>range()</b> method creates a bound for the data to be used for further processing.</p>
				<pre>
				<span>var firstFlow = Flow.from([1,2,3,4,5,6,7]);</span>
				<span></span>
				<span>// anotherFlow contains [1,2,3,4,5,6,7,8,9]  </span>
				<span>var anotherFlow = firstFlow.range(2, 8);	// another flow contains: [3,4,5,6,7,8]</span>
				</pre>
				<p>Syntax</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.range(startIndex, endIndex)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;startIndex: an integer indicating the index of the first element (inclusive).</p>  
				<p>&nbsp;&nbsp;&nbsp;&nbsp;endIndex: an integer indicating the index of the last element (exclusive).</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow that contains data with indices between startIndex (inclusive) and endIndex (exclusive) in the calling flow.</p>
	  		</div>

	  		<div id="discretize">
	  			<h3>Flow.discretize()</h3>
	  			<p>The <b>discretize()</b> method create a discretized flow on a flow.</p>

				<pre>
				<span>jdata{</span>
				<span>	int x as logger;</span>
				<span>	f as flow with flowFunc of x;</span>
				<span>}</span>
				<span></span>
				<span>function flowFunc(inputFlow){</span>
				<span>	return inputFlow.discretize(2, 4);</span>
				<span>}</span>
				</pre>
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;discretize(numDevice, numData)</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;numDevice: the number of devices from whom to collect data.</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;numData: the number of data to collect.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A discretized flow.</p>
			</div>

			<!--END OF FLOW METHODS-->

			<!--FLOW ACTIONS-->

			<div id="flow-actions">
				<h3>Flow Actions</h3>
				<p>Flow actions are operations that yield results that are not themselves Flows. When an action is called on a Flow, the Flow engine begins operating on the data and pipes each produces data to the next layer until the condition for the action is met. The currently supported actions are listed below:</p>
			</div>

			<div id="count">
				<h3>Flow.count()</h3>
				<p>The <b>count()</b> function calculates the number of data in a finite data flow</p>

				<pre>
				<span>//get the count of all the even numbers from the array</span>
				<span>var count = Flow.from([1,2,3,4,5,6,7,8,9]).where(num => num % 2 == 0).count();</span>
				<span>//returns 4</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;count()</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;The number of data in the flow.</p> 
			</div>
			
			<div id="sum">
				<h3>Flow.sum()</h3>
				<p>The <b>sum()</b> method calculates the sum of numbers in a finite data flow</p>

				<pre>
				<span>jdata{</span>
				<span>	int x as logger;</span>
				<span>	f as flow with flowFunc of x;</span>
				<span>}</span>
				<span></span>
				<span>function flowFunc(inputFlow){</span>
				<span>	return inputFlow.discretize(2, 4);</span>
				<span>}</span>
				<span></span>
				<span>f.setTerminalFunction(function(discretizedFlow){</span>
				<span>	var sum = (discretizedFlow.selectFlatten().select(entry=>entry.data).sum());</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;sum()</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;The sum of numbers in the flow.</p>  
			</div>

			<div id="max">
				<h3>Flow.max()</h3>
				<p>The <b>max()</b> method calculates the maximum number in a finite data flow</p>

				<pre>
				<span>jdata{</span>
				<span>	int x as logger;</span>
				<span>	f as flow with flowFunc of x;</span>
				<span>}</span>
				<span></span>
				<span>function flowFunc(inputFlow){</span>
				<span>	return inputFlow.discretize(2, 4);</span>
				<span>}</span>
				<span></span>
				<span>f.setTerminalFunction(function(discretizedFlow){</span>
				<span>	var max = (discretizedFlow.selectFlatten().select(entry=>entry.data).max());</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;max()</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;The maximum number in the flow.</p>  
		  	</div>

		  	<div id="min">
		  		<h3>Flow.min()</h3>	
				<p>The <b>min()</b> method calculates the minimum number in a finite data flow</p>

				<pre>
				<span>jdata{</span>
				<span>	int x as logger;</span>
				<span>	f as flow with flowFunc of x;</span>
				<span>}</span>
				<span></span>
				<span>function flowFunc(inputFlow){</span>
				<span>	return inputFlow.discretize(2, 4);</span>
				<span>}</span>
				<span></span>
				<span>f.setTerminalFunction(function(discretizedFlow){</span>
				<span>	var min = (discretizedFlow.selectFlatten().select(entry=>entry.data).min());</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;min()</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;The minimum number in the flow.</p>  
			</div>

			<div id="average">
				<h3>Flow.average()</h3>
				<p>The <b>average()</b> function calculates the average of numbers in a finite data flow</p>

				<pre>
				<span>jdata{</span>
				<span>	int x as logger;</span>
				<span>	f as flow with flowFunc of x;</span>
				<span>}</span>
				<span></span>
				<span>function flowFunc(inputFlow){</span>
				<span>	return inputFlow.discretize(2, 4);</span>
				<span>}</span>
				<span></span>
				<span>f.setTerminalFunction(function(discretizedFlow){</span>
				<span>	var average = (discretizedFlow.selectFlatten().select(entry=>entry.data).average());</span>
				<span>});</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;average()</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;The average value of numbers in the flow.</p> 
			</div>

			<div id="groupby">
				<h3>Flow.groupBy()</h3>
				<p>The <b>groupBy()</b> method returns a new Flow containing several datasets grouped by a specified key.</p> 
				<pre>
				<span>var firstFlow = Flow.from([</span>
				<span>	{	</span>
				<span>		type: "student",</span>
				<span>		year: "U2"</span>
				<span>		name: "Lilly"</span>
				<span>	},</span>
				<span>	{</span>
				<span>		type: "student",</span>
				<span>		year: "U0"</span>
				<span>	},</span>
				<span>	{</span>
				<span>		type: "professor",</span>
				<span>		name: "Tom"</span>
				<span>	},</span>
				<span>	{</span>
				<span>		type: "professor",</span>
				<span>	}</span>
				<span>]);</span>
				<span></span>
				<span>/* anotherFlow contains </span>
				<span>{</span>
				<span>	"student": [</span>
				<span>		{	</span>
				<span>			type: "student",</span>
				<span>			year: "U2"</span>
				<span>			name: "Lilly"</span>
				<span>		},</span>
				<span>		{</span>
				<span>			type: "student",</span>
				<span>			year: "U0"</span>
				<span>			name: "Jim"</span>
				<span>		}</span>
				<span>	],</span>
				<span>	"professor":[</span>
				<span>		{</span>
				<span>			name: "Tom"</span>
				<span>		},</span>
				<span>		{</span>
				<span>			type: "professor",</span>
				<span>			name: "Anne"</span>
				<span>	]</span>
				<span>}</span>
				<span>*/</span>
				<span>var anotherFlow = firstFlow.groupBy("type");</span>
				</pre>  
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.groupBy(key)</p>
				<p>Parameter</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;key: a string indicating the key used to group data in the calling flow.</p>
				<p>Return value</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow containing data in the calling flow partitioned into groups of array determined by the values of the intended key.</p>
			</div>

			<div id="findfirst">
				<h3>Flow.findFirst()</h3>
				<p>The <b>findFirst()</b> function finds the first data in a finite flow</p>

				<pre>
				<span>//get the first even number</span>
				<span>var first = Flow.from([1,2,3,4,5,6,7,8,9]).where(num => num % 2 == 0).findFirst();</span>
				<span>//returns 2</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;findFirst()</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;The first data in the flow.</p> 
			</div>

			<div id="findlast">
				<h3>Flow.findLast()</h3>
				<p>The <b>findLast()</b> finds the last data in a finite flow</p>

				<pre>
				<span>//get the first even number</span>
				<span>var first = Flow.from([1,2,3,4,5,6,7,8,9]).where(num => num % 2 == 0).findLast();</span>
				<span>//returns 9</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;findLast()</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;The last data in the flow.</p> 
			</div>

			<div id="collect">
				<h3>Flow.collect()</h3>
				<p>The <b>collect()</b> function finds the first data in the flow</p>

				<pre>
				<span>var firstFlow = Flow.from([</span>
				<span>	{	</span>
				<span>		type: "student",</span>
				<span>		year: "U2"</span>
				<span>		name: "Lilly"</span>
				<span>	},</span>
				<span>	{</span>
				<span>		type: "student",</span>
				<span>		year: "U0"</span>
				<span>	},</span>
				<span>	{</span>
				<span>		type: "professor",</span>
				<span>		name: "Tom"</span>
				<span>	},</span>
				<span>	{</span>
				<span>		type: "professor",</span>
				<span>	}</span>
				<span>]);</span>
				<span></span>
				<span>var types = firstFlow.select("type").collect();</span>
				<span>// types is ["student", "professor"]</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;collect([collectMethod])</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;collectMethod (optional): a Flow internal function which can either be <code>Flow.toSet()</code>, <code>Flow.toArray()</code> or <code>Flow.toMap(keyFunc)</code>. It is also possible to ignore the parenthesis for the array and set as <code>Flow.toArray</code> and <code>Flow.toSet</code> respectively. Collecting with <code>Flow.toSet</code> returns a distinct dataset, collecting with <code>Flow.toArray</code> returns all the data left after the last Flow method as an array while collecting with <code>Flow.toMap(keyFunc)</code> returns a JS ES6 Map. The keyFunc in <code>Flow.toMap()</code> is same as the function supplied to groupBy(). The only difference between calling collect with <code>toMap(keyFunc)</code> and calling <code>groupBy(keyFunc)</code> is that <code>toMap</code> returns an ES6 Map object while <code>groupBy</code> returns a plain JS object.<br>Its default value is Flow.toArray.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A data structure as specified by the argument that contains a collection of values in the flow.</p> 
			</div>

			<div id="join">
				<h3>Flow.join()</h3>
				<p>The <b>join()</b> function joins the outputs by a delimiter</p>

				<pre>
				<span>var joined = Flow.from([1,2,3,4,5]).map(num => num * 5).limit(3).join(" | ");</span>
				<span>//returns 5 | 10 | 15</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;join(delimiter)</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;delimiter (optional): the delimiter used to separate data in the output.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A string containing data from the previous flow separated by the delimiter.</p> 
			</div>

			<div id="foreach">
				<h3>Flow.forEach()</h3>
				<p>The <b>forEach()</b> function applies a custom operation on every data from the previous flow.</p>

				<pre>
				<span>//print all even numbers to the console</span>
				<span>Flow.from([1,2,3,4,5,6,7,8,9]).where(num => num % 2 == 0).foreach(console.log);</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;forEach(aFunction)</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: the operation to apply to each data in the previous flow.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;None.</p> 
			</div>

			<div id="anymatch">
				<h3>Flow.anyMatch()</h3>
				<p>The <b>anyMatch()</b> function checks if any of the remaining data matches the definition in the user defined function.</p>

				<pre>
				<span>//check if there is any number in the array that if we multiply with 5 yields 35</span>
				<span>var match = Flow.from([1,2,3,4,5,6,7,8,9]).anyMatch(num => num * 5 == 35);</span>
				<span>//returns true</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;anyMatch(aFunction)</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: the function used to evaluate the data in the previous flow.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A boolean value: true if there is a data in the flow on which the user-defined function returns true; false otherwise.</p> 
			</div>

			<div id="allmatch">
				<h3>Flow.allMatch()</h3>
				<p>The <b>allMatch()</b> function checks if all the remaining data match the definition in the user defined function.</p>

				<pre>
				<span>//check if all the numbers in the array yields 35 when multiplied by 5.</span>
				<span>var match = Flow.from([1,2,3,4,5,6,7,8,9]).allMatch(num => num * 5 == 35);</span>
				<span>//returns false</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;allMatch(aFunction)</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: the function used to evaluate the data in the previous flow.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A boolean value: true if the user-defined function returns true on all the data in the flow; false otherwise.</p> 
			</div>

			<div id="nonematch">
				<h3>Flow.noneMatch()</h3>
				<p>The <b>noneMatch()</b> function checks if none of the remaining data match the definition in the user defined function.</p>

				<pre>
				<span>//check if no numbers in the array yields 35 when multiplied by 5 </span>
				<span>var match = Flow.from([1,2,3,4,5,6,7,8,9]).noneMatch(num => num * 5 == 35);</span>
				<span>//returns false</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;noneMatch(aFunction)</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: the function used to evaluate the data in the previous flow.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A boolean value: true if the user-defined function returns false on all the data in the flow; false otherwise.</p> 
			</div>

			<div id="reduce">
				<h3>Flow.reduce()</h3>
				<p>The <b>reduce()</b> function allows a Flow to be reduced to a single value by applying a custom function on all the data in the previous flow to a user-supplied inital value.</p>

				<pre>
				<span>//let us implement getting the sum of numbers</span>
				<span>var sum = Flow.from([1,2,3,4,5]).reduce(0, (cv, nv) => cv + nv);</span>
				<span>//returns 15</span>
				</pre>

				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;reduce(init, aFunction)</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;init: the initial value to apply the cutom function to.</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;aFunction: the function applied to every data in the previous value. The function parameter takes two arguments (in the order: currentValue and newValue) and is expected to return a value which is further fed in as the currentValue for the next iteration.</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A value generated by chaining the custom function on each data in the previous flow.</p> 
			</div>
			<!--END OF FLOW ACTIONS-->

	  		<div id="iteratorflow"> 
				<h3>IteratorFlow</h3>
				<p>IteratorFlow is usually the first Flow created on raw data structures. Other flows can be created by applying flow methods on an iterator flow, which is the root flow in the flow chain and can be accessed via the property <code>rootFlow</code>.</p>

				<p><b>How to declare a IteratorFlow variable?</b></p>
				<p>An IteratorFlow can be built upon various data structures, including Array, Set, Map, Object, FileSystem, Generator, JAMDatasource and JAMDatastream.</p>
				<p>Unlike JAMDatasource which can only be declared inside a jdata{...} section, an IteratorFlow can be created both in or outside of it.</p>

				<p><b>Flow.from()</b> creates a IteratorFlow outside of jdata{...} section</p>

				<pre>
				<span>jdata{</span>
				<span>	&lt;loggerType&gt; &lt;loggerName&gt; as logger;</span>
				<span>}</span>
				<span></span>
				<span>// Creates a IteratorFlow on a JAMLogger</span>
				<span>var aFlow = Flow.from(&lt;loggerName&gt;);</span>
				<span></span>
				<span>var a = [1,2,3,4,5];</span>
				<span></span>
				<span>var f = Flow.from(a);</span>
				<span></span>
				<span>// creates a flow contains only the even number in firstFlow</span>
				<span>var anotherFlow = firstFlow.where(entry => entry.data%2==0);</span>
				</pre>
				<p><b>Syntax</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;Flow.from(data);</p>
				<p><b>Parameter</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A variable of type Array, Set, Map, Object, FileSystem, Generator, JAMDatasource or JAMDatastream</p>
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;An IteratorFlow contains all data in the argument data structure.</p>  
		  
				<p><b>Create an IteratorFlow in jdata{...} section</b></p>
				<p>An IteratorFlow built upon a JAMDatasource can be declared either in a jdata{...} section or outside as above.</p>

				<pre>
				<span>jdata{</span>
				<span>	&lt;dataType&gt; &lt;aDatasource&gt; as &lt;datasourceType&gt;;</span>
				<span>	&lt;flowName&gt; as flow with &lt;flowFunc&gt; of &lt;aDatasource&gt;;</span>
				<span>}</span>
				<span></span>
				<span>function &lt;flowFunc&gt; (rawFlow){</span>>
				<span>	// ...</span>
				<span>}</span>
				</pre>
				<p>Declare a JAMDatasource first. Then declare the IteratorFlow built upon it.</p>
				<p><code>&lt;flowName&gt;</code>: the name of this IteratorFlow variable.</p>  
				<p><code>&lt;flowFunc&gt;</code>: the name of the function to process the raw IteratorFlow from the intended logger.</p>  
				<p><code>&lt;aDatasource&gt;</code>: the name of the JAMDatasource variable on which this Iterator flow is initialized.</p>
				  
				<code>function &lt;flowFunc&gt; (rawFlow)</code>  
				<p>Every IteratorFlow on a JAMDatasource has to be associated with a function to process the raw flow.</p>
				<p><b>Parameter</b></p>
				<p>rawFlow: the raw IteratorFlow contains all data that the datasource on which the IteratorFlow is built recorded.</p>  
				<p><b>Return value</b></p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;A flow.</p> 

				<p><b>Example:</b> create an iterator flow on a logger that keeps track of weather.</p>
				<pre>
				<span>jdata{</span>
				<span>	struct weather{</span>
				<span>		int date;</span>
				<span>		int highTemperature;</span>
				<span>		int lowTemperature;</span>
				<span>		float humidity;</span>
				<span>		float wind;</span>
				<span>		char* airQuality;</span>
				<span>		char* UV;</span>
				<span>	} MTLWeather as logger;</span>
				<span></span>
				<span>	stats as flow with statsFunc of MTLWeather; </span>
				<span>}  </span>
				<span></span>
				<span>function statsFunc(rawFlow){</span>
				<span>	return rawFlow.select(function(entry){</span>
				<span>	});</span>
				<span>}</span>
				</pre>
				<p>The above code first declares a logger called <code>MTLWeather</code> with type <code>struct weather</code>, then an IteratorFlow with name <code>stats</code> and a function <code>statsFunc</code> on logger <code>MTLWeather</code>. <code>statsFunc</code> takes <code>stats</code> flow as its argument, and returns a flow created by a flow method <code>select</code>.</p>
			</div>

			<div id="outflow&inflow">
				<h3>OutFlow & InFlow</h3>
				<p>An OutFlow is responsible for processing and sending data across applications, while an InFlow is receiving data from other applications. In most cases, we let these two types of flow work together to perform communication between two JAM applications.</p>

				<p><b>How to declare an OutFlow variable?</b></p>
				<pre>
				<span>jdata{</span>
				<span>	&lt;dataType&gt; &lt;aDatasource&gt; as &lt;datasourceType&gt;;</span>
				<span>	&lt;flowName&gt; as flow with &lt;flowFunc&gt; of &lt;aDatasource&gt;;</span>
				<span>}</span>
				<span>  </span>
				<span>function &lt;flowFunc&gt; (rawFlow){</span>
				<span>	// ...</span>
				<span>}</span>
				<span></span>
				<span>&lt;outflowName&lt;.start();</span>
				</pre>

				<p>Declare an Iterator flow first, then create an outflow on it.</p>
				<p><code>outflowName</code>: the name of the outflow variable.</p>
				<p><code>flowName</code>: the name of the Iterator flow on which the outflow is created.</p>
				<p><code>&lt;outflowName&gt;.start()</code>: start piping data from flow to the outflow. Now the outflow contains all the data in the flow.</p>  
				<p><b>Example:</b> create an outflow as the socket that sends out data from a logger.</p>
				<pre>
				<span>jdata{</span>
				<span>	int sensorStatus as logger;</span>
				<span>	f as flow with flowFunc of sensorStatus;</span>
				<span>	outF as outflow of f; </span>
				<span>}</span>
				<span></span>
				<span>outF.start();</span>
				<span></span>
				<span>function flowFunc(inputFlow){</span>
				<span>	return inputFlow;</span>
				<span>}</span>
				</pre>
		  
				<p><b>How to declare an InFlow variable?</b></p>
				<pre>
				<span>jdata{</span>
				<span>	&lt;inflowName&gt; as inflow of app://&lt;outflowAPP&gt;.&lt;outflowName&gt;;</span>
				<span>}</span>
				</pre> 
				<p>Declare an inflow by specifying the path of the outflow it listens to.</p>
				<p><code>inflowName</code>: the name of the inflow variable.</p>
				<p><code>outflowAPP</code>: the name of the application where the outflow listened to resides.</p>  
				<p><code>outflowName</code>: the name of the outflow that the inflow listens to.</p>  
				<p><b>Example:</b> create an inflow as the listener socket for incoming data from an outflow in another application.</p>
				<pre>
				<span>jdata{</span>
				<span>	sensorStatus as inflow of app://t.outF;</span>
				<span>}</span>
				</pre>  
				<p>Here the outflow path is <code>app://t.outF</code>. <code>t</code> is the APP_NAME that we supplied to the J-node when running the outflow application. <code>outF</code> is the name of the outflow that feeds data to the inflow created.</p>
			</div>
			
			<div id="in&out-samples">
				<h3>Sample programs for your inspirations!</h3>
	  			<button class="myAccordion">Using outflow and inflow to share data between two applications</button>
	  			<div class="myPanel">
	  				<p>Outflow J-node</p>
	  				<pre>
					<span>jdata{</span>
					<span>	int sensorStatus as logger;</span>
					<span>	f as flow with flowFunc of sensorStatus;</span>
					<span>	outF as outflow of f; </span>
					<span>}</span>
					<span></span>
					<span>outF.start();</span>
					<span></span>
					<span>function flowFunc(inputFlow){</span>
					<span>	return inputFlow;</span>
					<span>}</span>
	  				</pre>

	  				<p>Outflow C-node</p>
	  				<pre>
	  				<span>#include &lt;unistd.h&gt;</span>
					<span>#include &lt;stdlib.h&gt;</span>
					<span></span>
					<span>int main() {</span>
					<span>	int sensorStatus;</span>
					<span>	for (int i = 1;; i++) {</span>
					<span>		sensorStatus = rand()%2; </span>
					<span>		sleep(1);</span>
					<span>	}</span>
					<span>}</span>
	  				</pre>

	  				<p>Inflow J-node</p>
	  				<pre>
  					<span>jdata{</span>
					<span>	sensorStatus as inflow of app://t.outF;</span>
					<span></span>
					<span>	struct weather{</span>
					<span>		int date;</span>
					<span>		int highTemperature;</span>
					<span>		int lowTemperature;</span>
					<span>		float humidity;</span>
					<span>		float wind;</span>
					<span>		char* airQuality;</span>
					<span>		char* UV;</span>
					<span>	} MTLWeather as logger;</span>
					<span></span>
					<span>	stats as flow with statsFunc of MTLWeather; </span>
					<span>}</span>
					<span></span>
					<span>function statsFunc(inputFlow){</span>
					<span>	return inputFlow;</span>
					<span>}</span>
					<span></span>
					<span>var sensor = -1;</span>
					<span></span>
					<span>sensorStatus.setTerminalFunction(function(entry){</span>
					<span>	if(entry.data == 1 && sensor == -1){</span>
					<span>		sensor = 1; </span>
					<span>		console.log("*****SENSOR IS UP*****");</span>
					<span>		(function poll(){</span>
					<span>		    if( MTLWeather.size() < 1 ){</span>
					<span>		        console.log("waiting for a C-node");</span>
					<span>		        setTimeout(poll, 1000);</span>
					<span>		    }</span>
					<span>		    else</span>
					<span>		        stats.startPush();</span>
					<span>		})();</span>
					<span>	}</span>
					<span>	else if(entry.data == 0){</span>
					<span>		sensor = -1;</span>
					<span>		console.log("*****SENSOR IS DOWN*****");</span>
					<span>		stats.stopPush();</span>
					<span>	}</span>
					<span>});</span>
					<span></span>
					<span>stats.setTerminalFunction(function(entry){</span>
					<span>	console.log("Weather:",entry.data);</span>
					<span>});</span>
	  				</pre>

	  				<p>Inflow C-node</p>
	  				<pre>
	  				<span>#include &lt;unistd.h&gt;</span>
					<span>#include &lt;stdlib.h&gt;</span>
					<span></span>
					<span>int main() {</span>
					<span>	int low, diff, date;</span>
					<span>	float hum, wind;</span>
					<span></span>
					<span>	for (int i = 1;; i++) {</span>
					<span>		date = i%31+1,</span>
					<span>		low  = rand()%15+15;</span>
					<span>		diff = rand()%10;</span>
					<span>		hum  = (rand()%100)/100;</span>
					<span>		wind = rand()%25+(rand()%10)/10;</span>
					<span>		MTLWeather = {</span>
					<span>			.date: date,</span>
					<span>			.lowTemperature: low, </span>
					<span>			.highTemperature: low+diff,</span>
					<span>			.humidity: hum,</span>
					<span>			.wind: wind,</span>
					<span>			.airQuality: "good",</span>
					<span>			.UV: "strong"</span>
					<span>		};</span>
					<span>		sleep(1);</span>
					<span>	}</span>
					<span>}</span>
	  				</pre>
	  			</div>

	  		</div>

			<div id="discretizedflow">   
				<h4>DiscretizedFlow</h4>
				<p>This Flow splits data streams into chunks/windows to allow for Flow methods that require finite data operations.</p>
				<p>It allows us to only retrieve a specific amount of data from a specific number of devices.
				<p>For instance, we have a flow built on a logger, call it inputflow. Ten devices are pushing data to this logger, but we only want to see 4 data from the first 2 devices. We can then do <code>inputFlow.discretize(2, 4);</code>. We can visualize the discretized flow as following:</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>[[devA_data, devB_data], [devA_data, devB_data], [devA_data, devB_data, ], [devA_data, devB_data]]</code></p>
				<p>In order to apply flow operations on a discretized flow, we need to flatten it using <code>selectFlatten</code>, so that the above disretized flow will become:</p>
				<p><code>[[devA_data, devB_data, devA_data, devB_data, devA_data, devB_data, devA_data, devB_data]</code></p>
				  
	  		</div>

	  		<div id="discretized-samples">
	  			<h3>Sample programs for your inspirations!</h3>
	  			<button class="myAccordion">Manipulate a discretized flow with a wide range of flow operations</button>
	  			<div class="myPanel">
	  				<p>J-node</p>
	  				<pre>
	  				<span>jdata{</span>
					<span>	struct weather{</span>
					<span>		int date;</span>
					<span>		int highTemperature;</span>
					<span>		int lowTemperature;</span>
					<span>		float humidity;</span>
					<span>		float wind;</span>
					<span>		char* airQuality;</span>
					<span>		char* UV;</span>
					<span>	} MTLWeather as logger;</span>
					<span></span>
					<span>	stats as flow with statsFunc of MTLWeather; </span>
					<span>}</span>
					<span></span>
					<span></span>
					<span>function statsFunc(inputFlow){</span>
					<span>	return inputFlow.discretize(1, 31);</span>
					<span>}</span>
					<span></span>
					<span>stats.setTerminalFunction(function(f){</span>
					<span></span>
					<span>	console.log("*****Monthly Statistics*****");</span>					
					<span>	var month = f.selectFlatten();</span>
					<span>	console.log("Monthly hot days:", hotDays(month).count());</span>
					<span>	month.count();</span>
					<span>	prettyPrint(month);</span>
					<span></span>
					<span>	console.log("*****Weekly Statistics*****");</span>
					<span>	console.log("*****Week 1*****");</span>
					<span>	var week1 = weeklyStats(f, 1);</span>
					<span>	f.count();</span>
					<span></span>
					<span>	console.log("week1 hot days:", hotDays(week1).count());</span>
					<span>	week1.count();</span>
					<span>	prettyPrint(week1);</span>
					<span>	</span>
					<span></span>
					<span>	console.log("*****Week 2*****");</span>
					<span>	var week2 = weeklyStats(f, 2);</span>
					<span>	f.count();</span>
					<span></span>
					<span>	console.log("week2 hot days:", hotDays(week2).count());</span>
					<span>	week2.count();</span>
					<span>	prettyPrint(week2);</span>
					<span>	</span>
					<span></span>
					<span>	console.log("*****Week 3*****");</span>
					<span>	var week3 = weeklyStats(f, 3);</span>
					<span>	f.count();</span>
					<span></span>
					<span>	console.log("week3 hot days:", hotDays(week3).count());</span>
					<span>	week3.count();</span>
					<span>	prettyPrint(week3);</span>
					<span>	</span>
					<span></span>
					<span>	console.log("*****Week 4*****</span>
					<span>	var week4 = weeklyStats(f, 4);</span>
					<span>	f.count();</span>
					<span></span>
					<spam>	console.log("week4 hot days:", hotDays(week4).count());</spam>
					<span>	week4.count();</span>
					<span>	prettyPrint(week4);</span>
					<span>	</span>
					<span></span>
					<span>	console.log("*****periodStats: Date 20-25*****");</span>
					<span>	</span>
					<span>	var period = periodStats(f, 19, 25);</span>
					<span>	f.count();</span>
					<span></span>
					<span>	console.log("Period hot days:", hotDays(period).count());</span>
					<span>	period.count();</span>
					<span>	prettyPrint(period);</span>
					<span></span>
					<span>	console.log("*****highTemperature: low to high*****");</span>
					<span></span>
					<span>	f.count();</span>
					<span>	var byHighTemp = incOrderBy(f, "highTemperature");</span>
					<span>	prettyPrint(byHighTemp);</span>
					<span></span>
					<span>	console.log("*****humidity: high to low*****");</span>
					<span></span>
					<span>	f.count();</span>
					<span>	var byHumidity = decOrderBy(f, "humidity");</span>
					<span>	prettyPrint(byHumidity);</span>
					<span></span>
					<span>	console.log("*****Collect lowTemperature: low to high*****");</span>
					<span>	</span>
					<span>	f.count();</span>
					<span>	var byLowTemp = incOrderByProp(f, "lowTemperature");</span>
					<span>	console.log(byLowTemp.collect());</span>
					<span></span>	
					<span>	console.log("*****Week 1 temperature in Fahrenheit*****");</span>
					<span></span>
					<span>	week1.count();</span>
					<span>	var week1Fahrenheit = toFahrenheit(week1);</span>
					<span>	prettyPrint(week1Fahrenheit);</span>
					<span>});</span>
					<span></span>
					<span>(function poll(){</span>
					<span>   if( MTLWeather.size() < 1 ){</span>
					<span>        console.log("waiting for a C-node");</span>
					<span>        setTimeout(poll, 2000);</span>
					<span>    }</span>
					<span>    else</span>
					<span>        stats.startPush();</span>
					<span>})();</span>
					<span></span>
					<span>// @ args: a dicretized flow that has been flattened</span>
					<span>function prettyPrint(flattenedFlow){</span>
					<span>	</span>
					<span>	var size1 = String("|  highTemperature  ").length,</span>
					<span>		size2 = String("|  lowTemperature  ").length,</span>
					<span>		size3 = String("|  humidity  ").length,</span>
					<span>		size4 = String("|  wind  ").length,</span>
					<span>  	size5 = String("|  airQuality  ").length,</span>
					<span>		size6 = String("|  UV  ").length,</span>
					<span>		size7 = String("|  Date  |").length;</span>
					<span></span>
					<span>	console.log("|  Date  |  highTemperature  |  lowTemperature  |  humidity</span>
					<span>|wind  |  airQuality  |  UV  |");</span>
					<span></span>
					<span>	flattenedFlow.foreach(function(weather){</span>
					<span>		if(weather.data != undefined || weather.data != null)</span>
					<span>			weather = weather.data;</span>
					<span>		var sizeDiff;</span>
					<span></span>
					<span>		var s7 = "|  "+String(weather.date);</span>
					<span>		sizeDiff = size7-s7.length+1;</span>
					<span>		for(var i=0;i&lt;sizeDiff;i++){</span>
					<span>			s7+=" ";</span>
					<span>		}</span>
					<span></span>
							var s1 = "|  "+String(weather.highTemperature);
					<span>		sizeDiff = size1-s1.length+1;</span>
					<span>		for(var i=0;i&lt;sizeDiff;i++){</
					<span>			s1+=" ";</span>
					<span>		}</span>
					<span>		</span>
					<span></span>
					<span>		var s2 = "|  "+String(weather.lowTemperature);</span>
					<span>		sizeDiff = size2-s2.length+1;</span>
					<span>		for(i=0;i&lt;sizeDiff;i++){</
					<span>			s2+=" ";</span>
					<span>		}</span>
					<span></span>
					<span>		var s3 = "|  "+String(weather.humidity);</span>
					<span>		sizeDiff = size3-s3.length+1;</span>
					<span>		for(i=0;i&lt;sizeDiff;i++){</
					<span>			s3+=" ";</span>
					<span>		}</span>
					<span></span>
					<span>		var s4 = "|  "+String(weather.wind);</span>
					<span>		sizeDiff = size4-s4.length+1;</span>
					<span>		for(i=0;i&lt;sizeDiff;i++){</
					<span>			s4+=" ";</span>
					<span>		}</span>
					<span></span>
					<span>		var s5 = "|  "+String(weather.airQuality);</span>
					<span>		sizeDiff = size5-s5.length+1;</span>
					<span>		for(i=0;i&lt;sizeDiff;i++){</span>
					<span>			s5+=" ";</span>
					<span>		}</span>
					<span></span>
					<span>		var s6 = "|  "+String(weather.UV);</span>
					<span>		sizeDiff = size6-s6.length+1;</span>
					<span>		for(i=0;i&lt;sizeDiff;i++){</span>
					<span>			s6+=" ";</span>
					<span>		}</span>
					<span>		s6+="|";</span>
					<span></span>
					<span>		console.log(s7+s1+s2+s3+s4+s5+s6);</span>
					<span>	});</span>
					<span>};</span>
					<span></span>
					<span>/************FUNCTIONS FOR STATISTICS*************/</span>
					<span></span>
					<span>// @ args: a discretized flow that has been flattened</span>
					<span>// @ returns: a finite flattened flow containing data in flattenedFlow whose </span>
					<span>[hightTemperature] attribute >= 35</span>
					<span>function hotDays(flattenedFlow){</span>
					<span>	return flattenedFlow.where((entry) => entry.data.highTemperature>=35); </span>
					<span>};</span>
					<span></span>	
					<span>// @ args: </span>
					<span>// discretizedFlow: a discretized flow that has NOT been flattened</span>
					<span>// n: an integer indicates the index of the intended week</span>
					<span>// @ returns: a finite flattened flow containing data from the n-th week in</span>
					<span>// discretizedFlow</span>
					<span>var weeklyStats = function(discretizedFlow, n){</span>
					<span></span>
					<span>	var startingDate = (n-1)*7;</span>
					<span>	var endingDate = startingDate+7;</span>
					<span></span>
					<span>	return discretizedFlow.selectFlatten().range(startingDate, endingDate);</span>
					<span>};</span>
					<span></span>
					<span>// @ args: </span>
					<span>// discretizedFlow: a discretized flow that has NOT been flattened</span>
					<span>// startingDate: the starting date of the intended period (inclusive)</span>
					<span>// endingDate: the ending date of the intended period (exclusive)</span>
					<span>// @ returns: a finite flattened flow containing data from the period</span>
					<span>[startingDate, endingDate) in discretizedFlow</span>
					<span>var periodStats = function(discretizedFlow, startingDate, endingDate){</span>
					<span>	return discretizedFlow.selectFlatten().range(startingDate, endingDate);</span>
					<span>};</span>
					<span></span>
					<span>// @ args:</span>
					<span>// flattendFlow: a discretized flow that has been flattened</span>
					<span>// property: a string indicating the property to order by</span>
					<span>// @ returns: a finite flattened flow containing all data from flattenedFlow </span>
					<span>// incrementally ordered by property</span>
					<span>var incOrderBy = function(discretizedFlow, property){</span>
					<span></span>
					<span>	return discretizedFlow.selectFlatten().select(entry => entry.data).orderBy(</span>
					<span>	function(a, b){</span>
					<span>		if(a[property] &lt; b[property])</span>
					<span>			return -1;</span>
					<span>		if(a[property] &gt; b[property])</span>
					<span>			return 1;</span>
					<span>		return 0;</span>
					<span>	});</span>
					<span>};</span>
					<span></span>
					<span>// @ args:</span>
					<span>// flattendFlow: a discretized flow that has been flattened</span>
					<span>// property: a string indicating the property to order by</span>
					<span>// @ returns: a finite flattened flow containing all data from flattenedFlow </span>
					<span>// decrementally ordered by property</span>
					<span>var decOrderBy = function(discretizedFlow, property){</span>
					<span>	return discretizedFlow.selectFlatten().select(entry => entry.data).orderBy(</span>
					<span>function(a, b){</span>
					<span>		if(a[property] &lt; b[property])</span>
					<span>			return 1;</span>
					<span>		if(a[property] &gt; b[property])</span>
					<span>			return -1;</span>
					<span>		return 0;</span>
					<span>	});</span>
					<span>};</span>
					<span></span>
					<span>// @ args:</span>
					<span>// flattendFlow: a discretized flow that has been flattened</span>
					<span>// property: a string indicating the property to order by</span>
					<span>// @ returns: a finite flattened flow containing all data[property] from </span>
					<span>// flattenedFlow that is incrementally ordered</span>
					<span>var incOrderByProp = function(discretizedFlow, property){</span>
					<span>	var propertyFlow = discretizedFlow.selectFlatten().select(entry => .data).select(function(weather){ </span>
					<span>		return weather[property];</span>
					<span>	});</span>
					<span></span>
					<span>	return propertyFlow.orderBy();</span>
					<span>};</span>
					<span></span>
					<span>// @ args:</span>
					<span>// flattendFlow: a discretized flow that has been flattened</span>
					<span>// property: a string indicating the property to order by</span>
					<span>// @ returns: a finite flattened flow containing all data[property] from </span>
					<span>// flattenedFlow that is decrementally ordered</span>
					<span>var decOrderByProp = function(flattenedFlow, property){</span>
					<span>	</span>
					<span>	var propertyFlow = flattenedFlow.select(entry => entry.data).select(function(weather){</span>
					<span>		return weather[property];</span>
					<span>	});</span>
					<span></span>
					<span>	return propertyFlow.orderBy(function(a,b){</span>
					<span>		if(a&lt;b) return 1;</span>
					<span>		if(a&gt;b) return -1;</span>
					<span>		return 0;</span>
					<span>	});</span>
					<span>};</span>
	  				</pre>

	  				<p>C-node</p>
	  				<pre>
	  				<span>#include &lt;unistd.h&gt;</span>
					<span>#include &lt;stdlib.h&gt;</span>
					<span></span>
					<span>int main() {</span>
					<span>	int low, diff, date;</span>
					<span>	float hum, wind;</span>
					<span></span>
					<span>	for (int i = 1;; i++) {</span>
					<span>		date = i%31+1,</span>
					<span>		low  = rand()%15+15;</span>
					<span>		diff = rand()%10;</span>
					<span>		hum  = (rand()%100)/100;</span>
					<span>		wind = rand()%25+(rand()%10)/10;</span>
					<span>		MTLWeather = {</span>
					<span>			.date: date,</span>
					<span>			.lowTemperature: low, </span>
					<span>			.highTemperature: low+diff,</span>
					<span>			.humidity: hum,</span>
					<span>			.wind: wind,</span>
					<span>			.airQuality: "good",</span>
					<span>			.UV: "strong"</span>
					<span>		};</span>
					<span>		usleep(30000);</span>
					<span>	}</span>
					<span>}</span>
	  				</pre>
	  			</div>
	  		</div>

	  		
  	</div>

  	<div id="top-btn"><a href="top">TOP</a></div>
	<script>
		var acc = document.getElementsByClassName("myAccordion");
		var i;

		for (i = 0; i < acc.length; i++) {
		    acc[i].onclick = function(){
		        /* Toggle between adding and removing the "active" class,
		        to highlight the button that controls the panel */
		        this.classList.toggle("active");

		        /* Toggle between hiding and showing the active panel */
		        var panel = this.nextElementSibling;
		        if (panel.style.display === "block") {
		            panel.style.display = "none";
		        } else {
		            panel.style.display = "block";
		        }
		    }
		}
	</script>
</body>
