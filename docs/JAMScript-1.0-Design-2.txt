
JAMScript 1.0 Design Notes (Simplified Design)
==============================================

INTRODUCTION

JAMScript is an extention of the JADE programming framework (see [1]).
Several new features have been added to JADE to create JAMScript. In particular,
the following extensions have been made to JADE as presented in [1].
    * Support for exceptions. Using exceptions we could improve the reliability
      of the programs written in JAMScript. There are two types of exceptions: one
      generated by the program itself and another generated by the system (runtime).
    * External global registers. The global registers are readonly for the JAMScript
      programs. We can write a JAMScript program that would be triggered when a register
      is updated.

We are working on JAMScript with the intention of developing a language for IoT, Cloud,
and Web programming. However, a language such as JAMScript could address another need:
an easier way of interfacing C/C++ with JavaScript. Looking at the Node.js and JavaScript
forums it seems there is lot of interest in a simple way of interfacing C/C++ programs
with JavaScript and Node.js in particular. Developing a Node.js addon is the prescribed way
of interfacing the two at this time. With JAMScript we could introducing another approach
that I believe is much simpler and does not pollute either.

The JAMScript relies on a shared execution model. In the `shared' model, we run the C/C++ program
and JavaScript program. It does not mean that the memory is shared - that is the variables
get shared access to values.

The C/C++ and JavaScript code segments have access to the same global variables. However, the
list of shared global variables might be restricted by the `machine' definition. The exceptions
generated by one can affect the other.

SUMMARY of JAMScript DESIGN

1.  jamdef retval c_function_decl(param_list) {

        // JavaScript definition of the C function

    } onreturn c_function_decl(param_list) {

        // C function definition

    } oncatch jamexception() c_function_decl(int ecode, char *emsg) {

        // C function definition
    }

    jamdef is responsible for linking a segment of JavaScript code with a segment of C/C++
    code. Using jamdef the JavaScript code is encapsulated as a C function. Now the JavaScript
    code segment can be called from a C/C++ segment as if it was a C function.

    Both segments run in a shared execution space. They have access to certain predefined
    global variables. Also, they can affect each other through exceptions.


2.  jamcall retval c_function(param_list) {

        // C function definition
    }

    jamcall is responsible for linking a segment of C code to a JavaScript code. The reverse
    of jamdef. Here we have a C function and want to make it available for calling from
    JavaScript code. We could consider a situation where a C function is calling another C
    function through JavaScript too. That is we have jamcall and jamdef in play here. What
    benefits for doing this, I don't know!


3.  jamtry c_function(param_list) {

        // C function definition

    } oncatch jamexception



Runtime is responsible for setting up the exception parameters. The C function
is called with the appropriate parameters. Do we provide any C exception functions
as well? Any C based API to manipulate the SDM? This might be necessary as well.


2.  jamcall retval c_function_decl(param_list) {


    }



support for the physical object model (POM) has been integrated into the script.

DESCRIPTION

In this section, we describe JAMScript 1.0 for mixing with C programming language.
The key facility provided by JAMScript is to define a function that is callable
from C (i.e., in the 'thing'), while it is actually implemented in JavaScript. So
the function actually runs in the cloud or web. We use the following syntax


jamdef {options} function_definition [onreturn return_function_def]

    The function_definition here is a little different from the ordinary. The
    body of the function is in JavaScript and the declaration is in C.
    The C function declaration gives the 'name of the function' and the 'list of
    arguments.' The list of arguments specifies the 'type' of the arguments and their
    names. Although C compilers would not complain for missing 'type'. We enforce
    the type here. So the JAMScript translator is going to check and flag an error
    for missing types. The JAMScript translator is going to build a type table and then
    check whether the JavaScript code inside the body is actually using them. Any
    'unused' parameter value will generate a warning. The developer is expected to use this
    warning to track down invalid use.

    jamdef {dest=<destination>} function_declaration_in_C {
    	   // JavaScript body
    } onreturn function_declaration_in_C {
      	   // C body
    }

    Example:

    jamdef {dest=cloud} void dummyfunc(int a, int b) {
    	   // JavaScript code follows
	   var res = call_js_dummy(a, b);
	   console.log("Result " + res);
    }

    The is an asynchronous call. In the C program you call the
    'dummyfunc' with two integer parameters like
    dummyfunc(10, 20). This will initiate a call to the cloud and
    run a JavaScript function that includes the JavaScript code in the body.
    This JavaScript function is passed the values passed to the C function.

    We can also do the call (still asynchronously) but expect a callback
    once the computation is done. Note in the above function there is no
    return value. As in the normal function call, the return values cannot
    be given back here. Nor is it desirable for us to have synchronous function
    call because there could be long wait while no activity could be taking place
    in the 'thing'. Therefore, we have the 'onreturn' clause in the 'jamdef'.

    It is important to observe a difference between the function that is
    specified in the 'jamdef' part and the one specified in the 'onreturn' part.
    In this part, the function is actually completely in C. Unlike the former
    one which runs in the cloud or web, this one runs in the thing.

    The input parameter of the function specified in the 'onreturn' part
    is the return value of the 'jamdef' function. If the 'jamdef' part
    does not return any value, we cannot have an 'onreturn' part.

jammodel {options} model_definition

    We don't intend to specify everything about the 'thing' using a low-level
    programming language such as C. We want to leverage the expressive power
    of XML for specifying certain attributes of the thing. This is the purpose
    of the 'jammodel' section.

    Using 'jammodel,' we specify the physical object model (POM) associated
    with the 'thing.' The POM could be used to quickly define many characteristics
    of a thing. For instance, we can say the 'type' or 'tag' value for the thing.
    Besides describing the properties of the thing, there are many interesting ideas
    surrounding a POM spec. One of them is to use the options to specify the type
    of things that can contain the given thing. Similarly, we define what type of things
    can be contained within the given thing. Such information can be used very
    effectively in self-organizing the information model when things are in close
    proximity.

    That is, the information contained in the 'jammodel' is used to compose the
    hierarchical POM that represents a situation when things come into a certain
    configuration. For example, when people walk into a room, their smartphones could
    register with the POM server representing the room. Effectively, the smartphones
    enter the room as well when the users enter them. Any event generated by the smartphone
    is immediately propagated to the room and then to the entity containing the room and
    so on.

    jammodel {options} pom_specification_in_xml

    Example:

    jammodel {servermode=true,pomserver=<parent_server>,root=<root_element>,options} pom_specification_in_xml

    If the 'servermode' is true it indicates that this node is willing to be a server in the POM hierarchy. This server
    will be automatically registered in the parent POM. Actually, it is enclosed in a <server> tag and inserted into the
    parent POM at the appropriate location.

    The 'pomserver' tag indicates the address of the parent server that is maintaining the root of the POM hierarchy.
    This device whether it is a server or not will try to access the POM hierarchy and insert itself into the
    global POM hierarchy.

    What will happen if this device is unable to access the given POM hierarchy server or no POM hierarchy server
    is specified? In the first case, it is obvious that this device could become the POM root provided if it can operate
    in servermode. If it cannot operate in the servermode, then the connection to POM fails. If the pomserver address
    is not specified, we expect the device to become a POM server itself. In that case, the servermode should have been
    enabled by setting it to true. If not, we flag a translation time error.

    CHECK??: POM specification could include more than the given 'thing.' Therefore, we need to
    have a 'root' option to point to the root element.

    QUESTION: How about event capture and bubbling?

    jammodel {...,event=capture|bubble,...} pom_spec_in_xml

    Event capture or bubbling can be specified as the possible ways of dealing with events generated
    by devices within the POM (i.e., the space defined by the POM spec.).

    QUESTION: How does 'jamsay' and 'jamlisten' work with the POM specification given in the 'jammodel'?

    jamsay and jamlisten should be working with the enclosing space. Therefore, the POM specification
    of the enclosing space is what is going to affect the operation of these constructs.


jamcall {options} function_definition

    jamcall is a way for us to expose a custom C function to the JavaScript side. The JavaScript
    function uses the same name as the C function as specified in the declaration. The object that
    is associated with the 'thing' contains the JavaScript function. A call to the JavaScript
    function triggers a call to the C function in the thing. The C function is registered as a
    callback.

    jamcall {params=value1,value2,value3,... valueN} function_definition

    In the above jamcall, the default values for the call are specified using the 'params' option.
    If the JavaScript call does not provide the same number of parameters as the C function, these
    values are used as defaults. If these default values are not specified, 0s or NULLs are used
    as defaults.

    We use the semantics of 'at most once' in JAMScript. The server (that is the receiving 'thing')
    can fail. Therefore, it is hard to ensure 'exactly once' semantics.

    Each jamcall will send a unique sequence number to the server (it is the thing here). The
    server would execute a jamcall only if the sequence number was not seen before.

    At least for now, we are ignoring the problem of partial executions. At a later time, we will
    investigate partial executions problem.

The following two JAM constructs are dealing with JAM events: production and consumption. A JAM
event has a type (an integer) and two other parameters: value and message. The value is again an
integer parameter and the message is a string. The value and message are arbitrarily set by the
application program. The type is again set by the application program; but, there should be
an agreement between the producer and consumer. Unless the type is matching, an event will not
be delivered to the consumer.

jamlisten [event-IDs] function_definition

    jamlisten is a way to designate a C function as the consumer of events. The function is
    triggered when an event of matching type is generated by another 'thing' and the POM
    delivers it to this thing. The listener is actually running on the device on which the
    JAMScript program is running. So the POM is responsible for delivering the event to this
    target. There are some important issues to be considered in the event delivery process.

    For instance, when an event is generated by a device it is routed to the highest element in
    the POM hierarchy that is in 'capture' mode. This is responsible for processing the event
    and then routing it to the appropriate lower-level element.

    We can use the jamlisten to subscribe to multiple event types.
    In that case, the given function is triggered if one of the event types arrive.

    As mentioned above, the event itself has two parameters. Therefore, the listening function
    should be capable of taking two parameters: first an integer parameter and second a char
    pointer to a null terminated string.

    The listening function is provided by the app developer and runs on the thing. So it
    processes the integer value and string in arbitrary ways.

jamsay event-ID {dist=multi|any} function_definition

    jamsay is a way to produce an event that is eventually going to be routed to a
    consumer. We can specify two different types of distribution schemes: multicast (actually
    sent to all possible receivers - remember this is not reliable multicast - it is
    actually an unreliable broadcast) and anycast (sent to one of the potential receivers).

    The C function should return a pointer to a structure with two parameters: first an integer
    value and the second a char pointer to a null-terminated string. If the function returns
    a NULL pointer, the event is not sent. Otherwise, the event is sent for distribution.
    There is no reliability guarantees offered on successful delivery of the event. There
    could be lost events. It is up to the app developer to ensure that the events are
    not processed multiple events if duplicating happen within the system. Duplicating is
    a possibility with multicasting turned on and is impossible with anycasting.

The following is a global JAM construct. It is meant to provide a facility to do global setup
such as including files and setting up global configuration. One of the key part of the
configuration is security setup.

QUESTION: Should we have a separate section such as 'jamsecurity' or 'jamconfigure' to setup
the security or just overload the 'jamrequire'.

jamrequire {
	// JavaScript require statements and other global definitions if necessary
}


Exception processing is very important in a complex system such as IoT, web, and cloud. We could have
exceptions generated due to variety of different situtations. These exceptions are different from
the events generated by the 'things'. Events are delivered through the POM and exceptions are not, they
are directly delivered to the things.

Also, exceptions can be generated by local actions and remote actions. There could be differentiations
in the 'code' included in the exceptions so that we could identify what is the source of the exception
and why it is actually generated.


jamtry void C_function_decl {
       // calling a mix of 'native' C
       // and jamdef functions - JS with C interfaces
} onexception C_function_definition

The 'jamtry' is a way to run a bunch of functions in the 'thing' and when an exception is generated
by the execution of one of the functions, the 'onexception' function is executed. It is important
to note that the 'jamtry' block can include 'local' functions and 'remote' functions. Local functions
are the ones that are running on the thing itself. The 'remote' functions are the ones that are
created using 'jamdef' to run on the cloud or web.

The C function given to the 'jamtry' should have a 'void' return type. Otherwise, we report an error.
The 'onexception' part executes a local function when the exception happens.

This function should be taking an integer (exception code) and a string (char *) for exception
message. The exception code and message can be processed in arbitrary ways by the developer supplied
function.

IMPORTANT: Each function within the 'jamtry' block needs to be synchronous. That is the functions
need to run one after the other. If we have asynchronous execution, then we are going to have
significant problems. That means, the 'jamdef' functions that are included in 'jamtry' needs to
work in synchronous mode. We need to ensure that the next function runs only when the 'jamdef'
function has returned from its call.

REMARK: This synchronous execution of the 'jamtry' block can introduce some limitations.
However, it seems that it is essential to manage the complexity of the exception management using
the 'jamtry' block.

To manage exception processing without requiring synchronous execution, we introduce the
'jamexception'

We need to have JAM exceptions that can work outside the 'jamtry' model because of its
'synchronous' limitation. To provide this facility, we need to introduce the 'jamexception'
construct. There are some challenges with a 'jamexception' construct: (a) needs to
trigger exceptions in the thing due to events that can take place in the 'thing', web, or cloud.
This is a big requirement.


jamexception void C_function_decl
{

}


The C_function_decl takes an integer and string parameters. The exceptions are generated by the JAM
runtime. There are various predefined exceptions supported by the JAM runtime. They should be
documented so that the developer can know the possible ways for handling them.


We may not even include the following constructs in JAMScript 1.0. They are included here for
completeness.

jamview {options} template_specification

    JAMScript allows us to write programs that display on the web. The web display needs markup.
    It is quite tedious if we have to programmatically generate that markup. The 'jamview'
    construct is a way of including a template in the JAMScript program.

    What are the options?

jamdata {options} function_definition

    The function is responsible for generating data at the 'thing'. This data stream should
    be stored in the cloud in a datastore - like a nosql database. The purpose of 'jamdata'
    is to actually do it.

    Again, what are the options? May be the tags or labels associated with the datastream
    when it is actually stored in the database.

jamobserver
    Do we need observers? How could they be used to implement publish/subscribe?
    What are the advantages?

    We are thinking of jamobserver in a "shared" memory model. The cloud here holds a shared memory
    model. There could be writes coming to the shared memory model. We need to have observers that
    could be triggered when changes occur to the shared variables. The observers could be put there
    by other things or the cloud.
