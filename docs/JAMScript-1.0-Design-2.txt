
JAMScript 1.0 Design Notes (Simplified Design)
==============================================

INTRODUCTION

JAMScript is an extension of the JADE programming framework (see [1]).
Several new features have been added to JADE to create JAMScript. In particular,
the following extensions have been made to JADE as presented in [1].
    * Support for exceptions. Using exceptions we could improve the reliability
      of the programs written in JAMScript. There are two types of exceptions: one
      generated by the program itself and another generated by the system (runtime).
    * External global registers. The global registers are readonly for the JAMScript
      programs. We can write a JAMScript program that would be triggered when a register
      is updated.

We are working on JAMScript with the intention of developing a language for IoT, Cloud,
and Web programming. However, a language such as JAMScript could address another need:
an easier way of interfacing C/C++ with JavaScript. Looking at the Node.js and JavaScript
forums it seems there is lot of interest in a simple way of interfacing C/C++ programs
with JavaScript and Node.js in particular. Developing a Node.js addon is the prescribed way
of interfacing the two at this time. With JAMScript we could introducing another approach
that I believe is much simpler and does not pollute either.

The JAMScript relies on a shared execution model. In the `shared' model, we run the C/C++ program
and JavaScript program. It does not mean that the memory is shared - that is the variables
get shared access to values.

The C/C++ and JavaScript code segments have access to the same global variables. However, the
list of shared global variables might be restricted by the `machine' definition. The exceptions
generated by one can affect the other.

SUMMARY of JAMScript DESIGN

1.  jamdef retval c_function_decl(param_list) {

        // JavaScript definition of the C function

    } onreturn c_function_decl(param_list) {

        // C function definition

    } oncatch (jamexception *e) c_function_decl(int e->code, char e->msg) {

        // C function definition
    }

    jamdef is responsible for linking a segment of JavaScript code with a segment of C/C++
    code. Using jamdef the JavaScript code is encapsulated as a C function. Now the JavaScript
    code segment can be called from a C/C++ segment as if it was a C function.

    Both segments run in a shared execution space. They have access to certain predefined
    global variables. Also, they can affect each other through exceptions.


2.  jamcall retval c_function(param_list) {

        // C function definition
    }

    jamcall is responsible for linking a segment of C code to a JavaScript code. The reverse
    of jamdef. Here we have a C function and want to make it available for calling from
    JavaScript code. We could consider a situation where a C function is calling another C
    function through JavaScript too. That is we have jamcall and jamdef in play here. What
    benefits for doing this, I don't know!

3.  jamtry c_function(param_list) {

        // C function definition

    } oncatch (jamexception *e) c_function_decl(int e->code, char e->msg) {

    }

    jamtry/oncatch is a way of adding exceptions to C language segments using the JAMScript
    constructs. What we do here is to put all the C language segments that need exception
    support into the c_function().


EXAMPLE CODE

1.  jamdef Examples


    jamdef void c_func(int x) {

        // JavaScript body.. just print the value of x..
        console.log("Param x = %d ", x);
    }

    The above example is the simplest possible jamdef construct. You just made a connection between
    the C function and the JavaScript function. When the C function is called, the JavaScript function
    is invoked. Here the invocation is asynchronous. The C function does not wait for the JavaScript
    function to complete or expect any return value from it. There is no acknowledgement from the called
    function. We don't even know whether the function got executed at the JavaScript side or not.

    Here is another example. The C function expects the JavaScript function to respond with a value.
    However, we should note that all function calls in JAMScript are asynchronous. That is, we don't
    block on any function call waiting for a response. This is good in terms of performance. However,
    we need to be careful with regard to reliability.

    jamdef int c_function(int x, int y) {

        // JavaScript body..
        return x + y;

    } onreturn ret_function(int rval) {

        console.log("Return val: %d", rval);
    }

    The C function and the corresponding JavaScript function return an integer value. With the
    jamdef, we have access to a C function called c_function(int x, int y); We call this function
    from a C/C++ program and the callback ret_function(int rval) will be called after
    the corresponding JavaScript function has completed its execution.

    Still we don't have any notification if there is a problem with the invocation. For instance,
    if there is an error of some sort that would not be known to the C side. We could use the
    next form of the jamdef construct to handle the exception situation.

    jamdef int c_function_could_fail(int z) {

        // JavaScript body..

    } onreturn ret_function(int rval) {

        // C function implementation .. do something.. this is the callback
        // only invoked when the JavaScript function that corresponds to the c_function
        // has returned..

    } oncatch (jamexception *e) exc_function(int e->code, char *e->msg) {

        // This is essentially an error callback. So this callback is only for
        // exception processing.
    }


2.  jamcall Examples



3.  jamtry Examples
