
JAMScript 1.0 Design Notes
==========================

INTRODUCTION

JAMScript is an extention of the JADE programming framework (see [1]).
Several new features have been added to JADE to create JAMScript. In particular,
support for the physical object model (POM) has been integrated into the script.

DESCRIPTION

In this section, we describe JAMScript 1.0 for mixing with C programming language. 
The key facility provided by JAMScript is to define a function that is callable 
from C (i.e., in the 'thing'), while it is actually implemented in JavaScript. So
the function actually runs in the cloud or web. We use the following syntax

    
jamdef {options} function_definition [onreturn return_function_def]

    The function_definition here is a little different from the ordinary. The 
    body of the function is in JavaScript and the declaration is in C.
    The C function declaration gives the 'name of the function' and the 'list of
    arguments.' The list of arguments specifies the 'type' of the arguments and their
    names. Although C compilers would not complain for missing 'type'. We enforce 
    the type here. So the JAMScript translator is going to check and flag an error
    for missing types. The JAMScript translator is going to build a type table and then
    check whether the JavaScript code inside the body is actually using them. Any 
    'unused' parameter value will generate a warning. The developer is expected to use this
    warning to track down invalid use.

    jamdef {dest=<destination>} function_declaration_in_C {
    	   // JavaScript body
    } onreturn function_declaration_in_C {
      	   // C body
    }

    Example:
    
    jamdef {dest=cloud} void dummyfunc(int a, int b) {
    	   // JavaScript code follows
	   var res = call_js_dummy(a, b);
	   console.log("Result " + res);
    }

    The is an asynchronous call. In the C program you call the
    'dummyfunc' with two integer parameters like
    dummyfunc(10, 20). This will initiate a call to the cloud and
    run a JavaScript function that includes the JavaScript code in the body.
    This JavaScript function is passed the values passed to the C function.

    We can also do the call (still asynchronously) but expect a callback
    once the computation is done. Note in the above function there is no
    return value. As in the normal function call, the return values cannot
    be given back here. Nor is it desirable for us to have synchronous function 
    call because there could be long wait while no activity could be taking place
    in the 'thing'. Therefore, we have the 'onreturn' clause in the 'jamdef'.

    It is important to observe a difference between the function that is
    specified in the 'jamdef' part and the one specified in the 'onreturn' part.
    In this part, the function is actually completely in C. Unlike the former
    one which runs in the cloud or web, this one runs in the thing.

    The input parameter of the function specified in the 'onreturn' part
    is the return value of the 'jamdef' function. If the 'jamdef' part 
    does not return any value, we cannot have an 'onreturn' part.


jammodel {options} model_definition
   
    We don't intend to specify everything about the 'thing' using a low-level
    programming language such as C. We want to leverage the expressive power
    of XML for specifying certain attributes of the thing. This is the purpose
    of the 'jammodel' section.

    Using 'jammodel,' we specify the physical object model (POM) associated 
    with the 'thing.' The POM could be used to quickly define many characteristics 
    of a thing. For instance, we can say the 'type' or 'tag' value for the thing. 
    Besides describing the properties of the thing, there are many interesting ideas
    surrounding a POM spec. One of them is to use the options to specify the type 
    of things that can contain the given thing. Similarly, we define what type of things
    can be contained within the given thing. Such information can be used very
    effectively in self-organizing the information model when things are in close
    proximity. 

    That is, the information contained in the 'jammodel' is used to compose the 
    hierarchical POM that represents a situation when things come into a certain
    configuration. For example, when people walk into a room, their smartphones could
    register with the POM server representing the room. Effectively, the smartphones
    enter the room as well when the users enter them. Any event generated by the smartphone
    is immediately propagated to the room and then to the entity containing the room and 
    so on. 

    jammodel {options} pom_specification_in_xml

    Example:

    jammodel {root=<root_element>,options} pom_specification_in_xml

    what options should we have?? How do specify the constraints on inclusion?

    POM specification could include more than the given 'thing.' Therefore, we need to
    have a 'root' option to point to the root element. 

    How do we specify the possibility that this element could be included in another hierarchy?
    
    How do we specify that other elements could be included within this one?


jamcall {options} function_definition

    jamcall is a way for us to expose a custom C function to the JavaScript side. The JavaScript
    function uses the same name as the C function as specified in the declaration. The object that
    is associated with the 'thing' contains the JavaScript function. A call to the JavaScript
    function triggers a call to the C function in the thing. The C function is registered as a
    callback. 

    jamcall {params=value1,value2,value3,... valueN} function_definition

    In the above jamcall, the default values for the call are specified using the 'params' option.
    If the JavaScript call does not provide the same number of parameters as the C function, these
    values are used as defaults. If these default values are not specified, 0s or NULLs are used
    as defaults. 

    We use the semantics of 'at most once' in JAMScript. The server (that is the receiving 'thing')
    can fail. Therefore, it is hard to ensure 'exactly once' semantics. 

    Each jamcall will send a unique sequence number to the server (it is the thing here). The 
    server would execute a jamcall only if the sequence number was not seen before.

    At least for now, we are ignoring the problem of partial executions. At a later time, we will 
    investigate partial executions problem. 


The following two JAM constructs are dealing with JAM events: production and consumption. A JAM
event has a type (an integer) and two other parameters: value and message. The value is again an
integer parameter and the message is a string. The value and message are arbitrarily set by the 
application program. The type is again set by the application program; but, there should be
an agreement between the producer and consumer. Unless the type is matching, an event will not
be delivered to the consumer. 

jamlisten [event-IDs] function_definition

    jamlisten is a way to designate a C function as the consumer of events. The function is
    triggered when an event of matching type is generated by another 'thing' and the POM 
    delivers it to this thing. We can use the jamlisten to subscribe to multiple event types.
    In that case, the given function is triggered if one of the event types arrive. 

    As mentioned above, the event itself has two parameters. Therefore, the listening function
    should be capable of taking two parameters: first an integer parameter and second a char
    pointer to a null terminated string. 

    The listening function is provided by the app developer and runs on the thing. So it 
    processes the integer value and string in arbitrary ways. 


jamsay event-ID {dist=multi|any} function_definition

    jamsay is a way to produce an event that is eventually going to be routed to a
    consumer. We can specify two different types of distribution schemes: multicast (actually
    sent to all possible receivers - remember this is not reliable multicast - it is
    actually an unreliable broadcast) and anycast (sent to one of the potential receivers). 

    The C function should return a pointer to a structure with two parameters: first an integer
    value and the second a char pointer to a null-terminated string. If the function returns
    a NULL pointer, the event is not sent. Otherwise, the event is sent for distribution. 
    There is no reliability guarantees offered on successful delivery of the event. There
    could be lost events. It is up to the app developer to ensure that the events are
    not processed multiple events if duplicating happen within the system. Duplicating is
    a possibility with multicasting turned on and is impossible with anycasting. 

The following is a convenience JAM construct. It is meant to provide a facility to include
arbitrary inclusions into the source file. 

jamrequire {
	// JavaScript require statements and other global definitions if necessary
}


We may not even include the following constructs in JAMScript 1.0. They are included here for
completeness.


jamview {options} template_specification

    JAMScript allows us to write programs that display on the web. The web display needs markup.
    It is quite tedious if we have to programmatically generate that markup. The 'jamview' 
    construct is a way of including a template in the JAMScript program. 

    What are the options?

jamdata {options} function_definition

    The function is responsible for generating data at the 'thing'. This data stream should
    be stored in the cloud in a datastore - like a nosql database. The purpose of 'jamdata'
    is to actually do it. 

    Again, what are the options? May be the tags or labels associated with the datastream
    when it is actually stored in the database.
