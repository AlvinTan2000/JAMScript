
JAMScript 1.0 Design Notes (Simplified Design)
==============================================

INTRODUCTION

JAMScript is an extension of the JADE programming framework (see [1]).
Several new features have been added to JADE to create JAMScript. In particular,
the following extensions have been made to JADE as presented in [1].
    * Support for exceptions. Using exceptions we could improve the reliability
      of the programs written in JAMScript. There are two types of exceptions: one
      generated by the program itself and another generated by the system (runtime).
    * External global registers. The global registers are readonly for the JAMScript
      programs. We can write a JAMScript program that would be triggered when a register
      is updated.

We are working on JAMScript with the intention of developing a language for IoT, Cloud,
and Web programming. However, a language such as JAMScript could address another need:
an easier way of interfacing C/C++ with JavaScript. Looking at the Node.js and JavaScript
forums it seems there is lot of interest in a simple way of interfacing C/C++ programs
with JavaScript and Node.js in particular. Developing a Node.js addon is the prescribed way
of interfacing the two at this time. With JAMScript we could introducing another approach
that I believe is much simpler and does not pollute either.

The JAMScript relies on a shared execution model. In the `shared' model, we run the C/C++ program
and JavaScript program. It does not mean that the memory is shared - that is the variables
get shared access to values.

The C/C++ and JavaScript code segments have access to the same global variables. However, the
list of shared global variables might be restricted by the `machine' definition. The exceptions
generated by one can affect the other.

SUMMARY of JAMScript DESIGN

1.  jamdef retval c_function_decl(arg_list) {

        // JavaScript function definition

    } onreturn c_function_decl(ret_arg_list) {

        // C function definition

    } oncatch (jamexception e if e of exceptiontype) retval c_function_decl(arg_list, int code, char *msg) {

        // JavaScript function definition
    }

    jamdef is responsible for linking a segment of JavaScript code with a segment of C/C++
    code. Using jamdef the JavaScript code is encapsulated as a C function. Now the JavaScript
    code segment can be called from a C/C++ segment as if it was a C function.

    This construct essentially runs a JavaScript code block when a C function is invoked.
    On success, a return C function would be called to process the returned value from the
    JavaScript code block. If there is an exception situation, we can retry with different
    JavaScript code blocks. There could be many "oncatch" clauses and one of them would be
    triggered when an exception occurs.

    We could use this pattern to implement recovery blocks. In this pattern, when the primary
    block fails, a secondary block is tried. What happens when a secondary block fails, I guess
    we could try another secondary block!

    TODO: C++ part is unknown. We need to fix this in version 1.1. I don't think the current
    construct will work as it is with C++.

2.  jamcall retval c_function(arg_list) {

        // C function definition

    } onreturn js_function_decl(ret_arg_list) {

        // JavaScript definition

    } oncatch (jamexception e if e of exceptiontype) retval c_function(arg_list, int code, char *msg) {

        // C function definition
    }

    jamcall is responsible for linking a segment of C code to a JavaScript code. The reverse
    of jamdef. Here we have a C function and want to make it available for calling from
    JavaScript code. We could consider a situation where a C function is calling another C
    function through JavaScript too. That is we have jamcall and jamdef in play here. What
    benefits for doing this, I don't know!

    This construct can be considered as an inverse of the jamdef. Here we are creating a JavaScript
    function from a C block. So the C block of code is called by invoking a JavaScript function.
    On success, we will return to the JavaScript side and run some function to process the
    returned values.

    When an exception occurs in the C function, the JAMScript could launch another C block.
    There could be many "oncatch" blocks and we could use them as recovery blocks. So we invoke
    one C function and if it fails for whatever the reason, then another C function is invoked
    depending on the exception being generated and the construction of the "oncatch" blocks.


3.  jamtry {

        // C function calls

    } oncatch (jamexception e if e of exceptiontype) c_function_decl(int code, char msg) {

        // Other C code..
    }

    This construct is little different from the other two. While the jamdef and jamcall are
    concerned with connecting C and JavaScript, jamtry is purely within C. We need this in
    C because C does not have exceptions. Even with a language with exceptions, this contruct
    could be useful because it exposes the problems to the JAMScript runtime. This information
    regarding the occurrence of the exceptions could be used for better fault tolerance.

    So we might want to use jamtry even with languages that have exceptions because we are
    exposing the exception conditions to the JAMScript runtime.


EXAMPLE CODE

1.  jamdef Examples


    jamdef void c_func(int x) {

        // JavaScript body.. just print the value of x..
        console.log("Param x = %d ", x);
    }

    The above example is the simplest possible jamdef construct. You just made a connection between
    the C function and the JavaScript function. When the C function is called, the JavaScript function
    is invoked. Here the invocation is asynchronous. The C function does not wait for the JavaScript
    function to complete or expect any return value from it. There is no acknowledgement from the called
    function. We don't even know whether the function got executed at the JavaScript side or not.

    Here is another example. The C function expects the JavaScript function to respond with a value.
    However, we should note that all function calls in JAMScript are asynchronous. That is, we don't
    block on any function call waiting for a response. This is good in terms of performance. However,
    we need to be careful with regard to reliability.

    jamdef int c_function(int x, int y) {

        // JavaScript body..
        return x + y;

    } onreturn ret_function(int rval) {

        console.log("Return val: %d", rval);
    }

    The C function and the corresponding JavaScript function return an integer value. With the
    jamdef, we have access to a C function called c_function(int x, int y); We call this function
    from a C/C++ program and the callback ret_function(int rval) will be called after
    the corresponding JavaScript function has completed its execution.

    Still we don't have any notification if there is a problem with the invocation. For instance,
    if there is an error of some sort that would not be known to the C side. We could use the
    next form of the jamdef construct to handle the exception situation.

    jamdef int c_function_could_fail(int z) {

        // JavaScript body..

    } onreturn ret_function(int rval) {

        // C function implementation .. do something.. this is the callback
        // only invoked when the JavaScript function that corresponds to the c_function
        // has returned..

    } oncatch (jamexception e) exc_function(int code, char *msg) {

        // This is essentially an error callback. So this callback is only for
        // exception processing.
    }

    Here is another complete example of the jamdef construct. First, the JAMScript code is shown
    and then the C and JavaScript codes that implement the JAMScript snippet are shown. We assume the
    existence of a set of routines bundled as JAMLib that can implement the intercommunication between
    the C and JavaScript programs and other required functions.

    jamdef double trigfunc(int a, double x) {

        // JavaScript code inside here..
        require ('jamlib');
        try {
            res = a / sin(x);

        } catch (e) {
            if (e instanceof RangeError) {
                // 105 here is just arbitary code.
                // We could even extract a code from e
                jamexception(105, "RangeError");
            }

        }
        return res;

    } onreturn printresult(double rval) {

        // This is actually C code!
        printf("Returned value %f", rval);

    } oncatch (jamexception e) double error_redo(int a, double x, int code, char *msg) {

        // In this particular example, redoing does not make any sense.
        // See NOTE below

        console.log("Error! Evaluating the trig function");
        return 0.0;
    }


NOTE: In general it makes sense to redo the computation. Depending on the situation that
    generated the exception, we could be using a whole different approach in the second
    attempt. Also, exposing the exception conditions to JAMScript can benefit. We could
    build the Circuit Breaker pattern into JAMScript so it automatically goes to "open"
    circuit if there are lot of errors within a short period. Then, the Circuit Breaker
    could heal to "closed".


2.  jamcall Examples




3.  jamtry Examples
