var readline = require('readline')


ometa CParser  {
  space           = ^space | fromTo('//', '\n') | fromTo('/*', '*/'),
  isKeyword :x    = ?CParser._isKeyword(x),
  nameFirst       = letter | '_',
  nameRest        = nameFirst | digit,
  iName           = <nameFirst nameRest*>,
  id              = iName:name ~isKeyword(name)                   -> [#id, name],
  keyword         = iName:kwd isKeyword(kwd)                      -> {console.log("Keyword: ", kwd); [kwd, kwd]},

  num             = digit+:ds                                     -> [#const, parseInt(ds.join(''))],

  escapeChar   = '\\' char:c                                      -> unescape('\\' + c),
  str          = seq('"""')  (escapeChar | ~seq('"""') char)*:cs seq('"""')        -> [#string, cs.join('')]
             | '\'' (escapeChar | ~'\'' char)*:cs '\''                             -> [#string, cs.join('')]
             | '"'  (escapeChar | ~'"'  char)*:cs '"'                              -> [#string, cs.join('')]
             | ('#' | '`') iName:n                                                 -> [#string, n],

  special         = ( ``...'' | ``>>='' | ``<<='' | ``+='' | ``-=''
                  | ``*='' | ``/='' | ``%='' | ``&='' | ``^=''
                  | ``|='' | ``>>'' | ``<<'' | ``++'' | ``--''
                  | ``->'' | ``&&'' | ``||'' | ``<='' | ``>=''
                  | ``=='' | ``!='' | ';' | '{' | '}' | ','
                  | ':' | '=' | '(' | ')' | '[' | ']' | '.'
                  | '&' | '!' | '~' | '-' | '+' | '*' | '/'
                  | '%' | '<' | '>' | '^' | '|' | '?' ):s         -> {console.log("Special:", s); [s, s]},

  scanner         = space* (id | num | special | keyword | str),
  token :k        = scanner:t ?(t[0] == k)      -> t[1],


  primary_expr    = "id"            -> console.log("match id")
                  | "const"         -> console.log("match const")
                  | "string"        -> console.log("Match String")
                  | "(" expression ")"    -> console.log("match (expr)"),

  postfix_expr    = postfix_expr "[" expression "]"
                  | postfix_expr "(" arg_expr_list* ")"
                  | postfix_expr "." "id"
                  | postfix_expr "->" "id"
                  | postfix_expr "++"
                  | postfix_expr "--"
                  | primary_expr,

  arg_expr_list   = arg_expr_list "," assign_expr     -> console.log("2 assign expr")
                  | assign_expr       -> console.log("match assign_expr"),

  unary_expr      = "++" unary_expr
                  | "--" unary_expr
                  | unary_operator cast_expr
                  | "sizeof" unary_expr
                  | "sizeof" "(" type_name ")"
                  | postfix_expr,

  unary_operator  = "&"
                  | "*"     -> console.log("Unary *")
                  | "+"     -> console.log("Unary +")
                  | "-"     -> console.log("Unary -")
                  | "~"
                  | "!",

//  cast_expr       = "(" type_name ")" cast_expr
//                  | unary_expr,
  cast_expr       = unary_expr,


  mult_expr       = mult_expr "*" cast_expr
                  | mult_expr "/" cast_expr
                  | mult_expr "%" cast_expr
                  | cast_expr,

  add_expr        = add_expr "+" mult_expr
                  | add_expr "-" mult_expr
                  | mult_expr,

  shift_expr      = shift_expr "<<" add_expr
                  | shift_expr ">>" add_expr
                  | add_expr,

  relational_expr = relational_expr "<" shift_expr
                  | relational_expr ">" shift_expr
                  | relational_expr "<=" shift_expr
                  | relational_expr ">=" shift_expr
                  | shift_expr,

  equality_expr   = equality_expr "==" relational_expr
                  | equality_expr "!=" relational_expr
                  | relational_expr,

  and_expr        = and_expr "&" equality_expr
                  | equality_expr,

  xor_expr        = xor_expr "^" and_expr
                  | and_expr,

  ior_expr        = ior_expr "|" xor_expr
                  | xor_expr,

  lor_expr        = lor_expr "&&" ior_expr
                  | ior_expr,

  cond_expr       = lor_expr "?" expression ":" cond_expr
                  | lor_expr,

  assign_expr     = unary_expr assign_op assign_expr  -> console.log("Unary expr")
                  | cond_expr                         -> console.log("Cond expr"),

  assign_op       = "="
                  | "*="
                  | "/="
                  | ">>="
                  | "<<="
                  | "+="
                  | "-="
                  | "%="
                  | "&="
                  | "|="
                  | "^=",

  expression      = expression "," assign_expr   -> console.log("2nd expression")
                  | assign_expr                   -> console.log("Assign expr"),

  const_expr      = cond_expr,

  declaration     = decl_specs init_decl* ";",

  decl_specs      = store_cl_spec decl_specs*
                  | type_spec decl_specs*
                  | type_qualifier decl_specs*,

  init_decl_list  = listOf('init_decl', ","),

  init_decl       = declarator "=" initializer
                  | declarator,

  store_cl_spec   = "typedef"
                  | "extern"
                  | "static"
                  | "auto"
                  | "register",

  type_spec       = "void"
                  | "char"
                  | "short"
                  | "int"
                  | "long"
                  | "float"
                  | "double"
                  | "signed"
                  | "unsigned"
                  | struct_uni_spec
                  | enum_spec
                  | "type_name",

  struct_uni_spec = struct_o_uni "id" "{" struct_decl_lst "}"
                  | struct_o_uni "{" struct_decl_lst "}"
                  | struct_o_uni "id",

  struct_o_uni    = "struct"
                  | "union",

  struct_decl_lst = struct_decl+,

  struc_decl      = spec_qual_list struct_decl_lst ";",

  spec_qual_list  = type_spec spec_qual_list
                  | type_spec
                  | type_qualifier spec_qual_list
                  | type_qualifier,

  struc_declr_lst = listOf('struct_declr', ","),

  struct_declr    = declarator ":" const_expr
                  | ":" const_expr
                  | declarator,

  enum_spec       = "enum" "id" "{" enumratr_lst "}"
                  | "enum" "{" enumratr_lst "}"
                  | "enum" "id",

  enumratr_lst    = listOf('enumerator', ","),

  enumerator      = "id" "=" const_expr
                  | "id",


  type_qualifier  = "const"
                  | "volatile",

  declarator      = pointer dir_declarator
                  | dir_declarator,

  dir_declarator  = dir_declarator "[" const_expr "]"
                  | dir_declarator "[" "]"
                  | dir_declarator "(" param_type_lst ")"
                  | dir_declarator "(" ident_lst ")"
                  | dir_declarator "(" ")"
                  | "(" declarator ")"
                  | "id",


  pointer         = "*" type_qual_list pointer
                  | "*" type_qual_list
                  | "*" pointer
                  | "*",

  type_qual_list  = type_qualifier+,

  param_type_lst  = param_list "," "..."
                  | param_list,

  param_list      = param_list "," param_decl
                  | param_decl,

  param_decl      = decl_specs declarator
                  | decl_specs abstract_decl
                  | decl_specs,

  ident_list      = ident_list "," "id"
                  | "id",

  type_name       = spec_qual_lst abstract_decl
                  | spec_qual_lst,

  abstract_decl   = pointer dir_abs_declr
                  | dir_abs_declr
                  | pointer,

  dir_abs_declr   = "(" abstract_decl ")"
                  | "[" const_expr "]"
                  | "[" "]"
                  | dir_abs_declr "[" const_expr "]"
                  | dir_abs_declr "[" "]"
                  | "(" param_type_lst ")"
                  | "(" ")"
                  | dir_abs_declr "(" param_type_lst ")"
                  | dir_abs_declr "(" ")",

  initializer     = "{" listOf('initializer_lst', ",") "}"
                  | assign_expr,

  initializer_lst = listOf('initializer', ","),


  statement       = labeled_stmt            -> console.log("Labeled stmt")
                  | compound_stmt           -> console.log("Compound stmt")
                  | expression_stmt         -> console.log("Expression stmt")
                  | selection_stmt          -> console.log("Selection stmt")
                  | iteration_stmt          -> console.log("Iteration stmt")
                  | jump_stmt               -> console.log("Jump stmt"),

  labeled_stmt    = "id" ":" statement
                  | "case" const_expression ":" statement
                  | "default" ":" statement,

  compound_stmt   = "{" declaration_lst statement_lst "}"
                  | "{" statement_lst "}"
                  | "{" declaration_lst "}"
                  | "{" "}",


  declaration_lst = declaration_lst declaration
                  | declaration,

  statement_lst   = statement+,

  expression_stmt = expression* ";",

  selection_stmt  = "if" "(" expression ")" statement "else" statement
                  | "if" "(" expression ")" statement
                  | "switch" "(" expression ")" statement,


  iteration_stmt  = "while" "(" expression ")" statement                    -> console.log("While! ")
                  | "do" statement "while" "(" expression ")" ";"
                  | "for" "(" expression_stmt expression_stmt ")" statement
                  | "for" "(" expression_stmt expression_stmt expression ")" statement,

  jump_stmt       = "goto" "id" ";"
                  | "continue" ";"
                  | "break" ";"
                  | "return" ";"
                  | "return" expression ";",


  translation_u   = external_decl+,

  external_decl   = function_def            -> console.log("Function def")
                  | declaration,


  function_def    = decl_specs declarator declaration_lst compound_stmt
                  | decl_specs declarator compound_stmt
                  | declarator declaration_lst compound_stmt
                  | declarator compound_stmt,

  top             = translation_u
}


// Setup the keywords; we can add more keywords to this list in
// an inherited parser that extends the C language!
//
CParser.keywords = {}
keywords = ["auto", "break", "case", "char", "const", "continue", "default", "do",
"double", "else", "enum", "extern", "float", "for", "goto", "if",
  "int", "long", "register", "return", "short", "signed", "sizeof", "static",
  "struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"];

for (var idx = 0; idx < keywords.length; idx++)
  CParser.keywords[keywords[idx]] = true;
CParser._isKeyword = function(k) { return this.keywords.hasOwnProperty(k); }


// SHOULD BE IN ANOTHER FILE
// FIGURE OUT HOW THE PARSER DEFINITION CAN BE A FILE BY ITSELF

var rl = readline.createInterface(process.stdin, process.stdout);
rl.setPrompt('CParser > ');
rl.prompt();


rl.on('line', function(line) {
	if (line === "right") rl.close();

	try {
	    tree = CParser.matchAll(line, 'top')
	} catch(e) {
	    console.log("\t\t\t\t ERROR! Invalid Input");
	}
	rl.prompt();
    }).on('close',function() {
	    process.exit(0);
	});
